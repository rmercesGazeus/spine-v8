{"version":3,"file":"SpinePipe.mjs","sources":["../src/SpinePipe.ts"],"sourcesContent":["/** ****************************************************************************\r\n * Spine Runtimes License Agreement\r\n * Last updated July 28, 2023. Replaces all prior versions.\r\n *\r\n * Copyright (c) 2013-2023, Esoteric Software LLC\r\n *\r\n * Integration of the Spine Runtimes into software or otherwise creating\r\n * derivative works of the Spine Runtimes is permitted under the terms and\r\n * conditions of Section 2 of the Spine Editor License Agreement:\r\n * http://esotericsoftware.com/spine-editor-license\r\n *\r\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\r\n * otherwise create derivative works of the Spine Runtimes (collectively,\r\n * \"Products\"), provided that each user of the Products must obtain their own\r\n * Spine Editor license and redistribution of the Products in any form must\r\n * include this license and copyright notice.\r\n *\r\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\r\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\r\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\r\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nimport {\r\n    collectAllRenderables,\r\n    extensions, ExtensionType,\r\n    InstructionSet,\r\n    type Renderer,\r\n    type RenderPipe,\r\n} from 'pixi.js';\r\nimport { BatchableSpineSlot } from './BatchableSpineSlot';\r\nimport { Spine } from './Spine';\r\nimport { MeshAttachment, RegionAttachment, SkeletonClipping } from '@esotericsoftware/spine-core';\r\n\r\nconst clipper = new SkeletonClipping();\r\n\r\nconst spineBlendModeMap = {\r\n    0: 'normal',\r\n    1: 'add',\r\n    2: 'multiply',\r\n    3: 'screen'\r\n};\r\n\r\n// eslint-disable-next-line max-len\r\nexport class SpinePipe implements RenderPipe<Spine>\r\n{\r\n    /** @ignore */\r\n    static extension = {\r\n        type: [\r\n            ExtensionType.WebGLPipes,\r\n            ExtensionType.WebGPUPipes,\r\n            ExtensionType.CanvasPipes,\r\n        ],\r\n        name: 'spine',\r\n    } as const;\r\n\r\n    renderer: Renderer;\r\n\r\n    private gpuSpineData:Record<string, any> = {};\r\n\r\n    constructor(renderer: Renderer)\r\n    {\r\n        this.renderer = renderer;\r\n    }\r\n\r\n    validateRenderable(spine: Spine): boolean\r\n    {\r\n        spine._applyState();\r\n\r\n        // if pine attachments have changed, we need to rebuild the batch!\r\n        if (spine.spineAttachmentsDirty)\r\n        {\r\n            return true;\r\n        }\r\n        // if the textures have changed, we need to rebuild the batch, but only if the texture is not already in the batch\r\n        else if (spine.spineTexturesDirty)\r\n        {\r\n            // loop through and see if the textures have changed..\r\n            const drawOrder = spine.skeleton.drawOrder;\r\n            const gpuSpine = this.gpuSpineData[spine.uid];\r\n\r\n            for (let i = 0, n = drawOrder.length; i < n; i++)\r\n            {\r\n                const slot = drawOrder[i];\r\n                const attachment = slot.getAttachment();\r\n\r\n                if (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment)\r\n                {\r\n                    const cacheData = spine._getCachedData(slot, attachment);\r\n                    const batchableSpineSlot = gpuSpine.slotBatches?.[cacheData.id];\r\n\r\n                    const texture = cacheData.texture;\r\n\r\n                    if (batchableSpineSlot && texture !== batchableSpineSlot?.texture)\r\n                    {\r\n                        if (!batchableSpineSlot._batcher.checkAndUpdateTexture(batchableSpineSlot, texture))\r\n                        {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    addRenderable(spine: Spine, instructionSet:InstructionSet)\r\n    {\r\n        const gpuSpine = this.gpuSpineData[spine.uid] ||= { slotBatches: {} };\r\n\r\n        const batcher = this.renderer.renderPipes.batch;\r\n\r\n        const drawOrder = spine.skeleton.drawOrder;\r\n\r\n        const roundPixels = (this.renderer._roundPixels | spine._roundPixels) as 0 | 1;\r\n\r\n        spine._applyState();\r\n\r\n        for (let i = 0, n = drawOrder.length; i < n; i++)\r\n        {\r\n            const slot = drawOrder[i];\r\n            const attachment = slot.getAttachment();\r\n            const blendMode = spineBlendModeMap[slot.data.blendMode];\r\n\r\n            if (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment)\r\n            {\r\n                const cacheData = spine._getCachedData(slot, attachment);\r\n                const batchableSpineSlot = gpuSpine.slotBatches[cacheData.id] ||= new BatchableSpineSlot();\r\n\r\n                batchableSpineSlot.setData(\r\n                    spine,\r\n                    cacheData,\r\n                    blendMode,\r\n                    roundPixels\r\n                );\r\n\r\n                if (!cacheData.skipRender)\r\n                {\r\n                    batcher.addToBatch(batchableSpineSlot, instructionSet);\r\n                }\r\n            }\r\n\r\n            const containerAttachment = spine._slotsObject[slot.data.name];\r\n\r\n            if (containerAttachment)\r\n            {\r\n                const container = containerAttachment.container;\r\n\r\n                container.includeInBuild = true;\r\n                collectAllRenderables(container, instructionSet, this.renderer);\r\n                container.includeInBuild = false;\r\n            }\r\n        }\r\n\r\n        clipper.clipEnd();\r\n    }\r\n\r\n    updateRenderable(spine: Spine)\r\n    {\r\n        // we assume that spine will always change its verts size..\r\n        const gpuSpine = this.gpuSpineData[spine.uid];\r\n\r\n        spine._applyState();\r\n\r\n        const drawOrder = spine.skeleton.drawOrder;\r\n\r\n        for (let i = 0, n = drawOrder.length; i < n; i++)\r\n        {\r\n            const slot = drawOrder[i];\r\n            const attachment = slot.getAttachment();\r\n\r\n            if (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment)\r\n            {\r\n                const cacheData = spine._getCachedData(slot, attachment);\r\n\r\n                if (!cacheData.skipRender)\r\n                {\r\n                    const batchableSpineSlot = gpuSpine.slotBatches[spine._getCachedData(slot, attachment).id];\r\n\r\n                    batchableSpineSlot?._batcher?.updateElement(batchableSpineSlot);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    destroyRenderable(spine: Spine)\r\n    {\r\n        // TODO remove the renderable from the batcher\r\n        this.gpuSpineData[spine.uid] = null as any;\r\n    }\r\n\r\n    destroy()\r\n    {\r\n        this.gpuSpineData = null as any;\r\n        this.renderer = null as any;\r\n    }\r\n}\r\n\r\nextensions.add(SpinePipe);\r\n"],"names":[],"mappings":"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"}