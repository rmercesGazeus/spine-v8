{"version":3,"file":"atlasLoader.js","sources":["../../src/assets/atlasLoader.ts"],"sourcesContent":["/** ****************************************************************************\r\n * Spine Runtimes License Agreement\r\n * Last updated July 28, 2023. Replaces all prior versions.\r\n *\r\n * Copyright (c) 2013-2023, Esoteric Software LLC\r\n *\r\n * Integration of the Spine Runtimes into software or otherwise creating\r\n * derivative works of the Spine Runtimes is permitted under the terms and\r\n * conditions of Section 2 of the Spine Editor License Agreement:\r\n * http://esotericsoftware.com/spine-editor-license\r\n *\r\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\r\n * otherwise create derivative works of the Spine Runtimes (collectively,\r\n * \"Products\"), provided that each user of the Products must obtain their own\r\n * Spine Editor license and redistribution of the Products in any form must\r\n * include this license and copyright notice.\r\n *\r\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\r\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\r\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\r\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nimport {\r\n    checkExtension,\r\n    DOMAdapter,\r\n    extensions,\r\n    ExtensionType,\r\n    LoaderParserPriority,\r\n    path,\r\n    TextureSource\r\n} from 'pixi.js';\r\nimport { SpineTexture } from '../SpineTexture';\r\nimport { TextureAtlas } from '@esotericsoftware/spine-core';\r\n\r\nimport type { AssetExtension, Loader, ResolvedAsset, Texture } from 'pixi.js';\r\n\r\ntype RawAtlas = string;\r\n\r\nconst spineTextureAtlasLoader: AssetExtension<RawAtlas | TextureAtlas, ISpineAtlasMetadata> = {\r\n    extension: ExtensionType.Asset,\r\n\r\n    loader: {\r\n        extension: {\r\n            type: ExtensionType.LoadParser,\r\n            priority: LoaderParserPriority.Normal,\r\n            name: 'spineTextureAtlasLoader',\r\n        },\r\n\r\n        test(url: string): boolean\r\n        {\r\n            return checkExtension(url, '.atlas');\r\n        },\r\n\r\n        async load(url: string): Promise<RawAtlas>\r\n        {\r\n            const response = await DOMAdapter.get().fetch(url);\r\n\r\n            const txt = await response.text();\r\n\r\n            return txt;\r\n        },\r\n\r\n        testParse(asset: unknown, options: ResolvedAsset): Promise<boolean>\r\n        {\r\n            const isExtensionRight = checkExtension(options.src as string, '.atlas');\r\n            const isString = typeof asset === 'string';\r\n\r\n            return Promise.resolve(isExtensionRight && isString);\r\n        },\r\n\r\n        unload(atlas: TextureAtlas)\r\n        {\r\n            atlas.dispose();\r\n        },\r\n\r\n        async parse(asset: RawAtlas, options: ResolvedAsset, loader: Loader): Promise<TextureAtlas>\r\n        {\r\n            const metadata: ISpineAtlasMetadata = options.data || {};\r\n            let basePath = path.dirname(options.src as string);\r\n\r\n            if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1)\r\n            {\r\n                basePath += '/';\r\n            }\r\n\r\n            // Retval is going to be a texture atlas. However we need to wait for it's callback to resolve this promise.\r\n            const retval = new TextureAtlas(asset);\r\n\r\n            // If the user gave me only one texture, that one is assumed to be the \"first\" texture in the atlas\r\n            if (metadata.images instanceof TextureSource || typeof metadata.images === 'string')\r\n            {\r\n                const pixiTexture = metadata.images;\r\n\r\n                metadata.images = {} as Record<string, TextureSource | string>;\r\n                metadata.images[retval.pages[0].name] = pixiTexture;\r\n            }\r\n\r\n            // we will wait for all promises for the textures at the same time at the end.\r\n            const textureLoadingPromises:Promise<any>[] = [];\r\n\r\n            // fill the pages\r\n            for (const page of retval.pages)\r\n            {\r\n                const pageName = page.name;\r\n                const providedPage = metadata?.images ? metadata.images[pageName] : undefined;\r\n\r\n                if (providedPage instanceof TextureSource)\r\n                {\r\n                    page.setTexture(SpineTexture.from(providedPage));\r\n                }\r\n                else\r\n                {\r\n                    // eslint-disable-next-line max-len\r\n                    const url: string = providedPage ?? path.normalize([...basePath.split(path.sep), pageName].join(path.sep));\r\n\r\n                    const assetsToLoadIn = {\r\n                        src: url,\r\n                        data: {\r\n                            ...metadata.imageMetadata,\r\n                            alphaMode: page.pma ? 'premultiplied-alpha' : 'premultiply-alpha-on-upload'\r\n                        }\r\n                    };\r\n\r\n                    const pixiPromise = loader.load<Texture>(assetsToLoadIn).then((texture) =>\r\n                    {\r\n                        page.setTexture(SpineTexture.from(texture.source));\r\n                    });\r\n\r\n                    textureLoadingPromises.push(pixiPromise);\r\n                }\r\n            }\r\n\r\n            await Promise.all(textureLoadingPromises);\r\n\r\n            return retval;\r\n        },\r\n    },\r\n} as AssetExtension<RawAtlas | TextureAtlas, ISpineAtlasMetadata>;\r\n\r\nextensions.add(spineTextureAtlasLoader);\r\n\r\nexport interface ISpineAtlasMetadata\r\n{\r\n    // If you are downloading an .atlas file, this metadata will go to the Texture loader\r\n    imageMetadata?: any;\r\n    // If you already have atlas pages loaded as pixi textures\r\n    // and want to use that to create the atlas, you can pass them here\r\n    images?: TextureSource | string | Record<string, TextureSource | string>;\r\n}\r\n"],"names":["ExtensionType","LoaderParserPriority","checkExtension","DOMAdapter","path","TextureAtlas","TextureSource","SpineTexture","extensions"],"mappings":"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"}