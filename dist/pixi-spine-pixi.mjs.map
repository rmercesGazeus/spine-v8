{"version":3,"file":"pixi-spine-pixi.mjs","sources":["../src/require-shim.ts","../src/SpineTexture.ts","../src/assets/atlasLoader.ts","../src/assets/skeletonLoader.ts","../src/darktint/DarkTintBatchGeometry.ts","../src/darktint/darkTintBit.ts","../src/darktint/DarkTintShader.ts","../src/darktint/DarkTintBatcher.ts","../src/BatchableSpineSlot.ts","../src/SpinePipe.ts","../src/Spine.ts","../src/SpineDebugRenderer.ts"],"sourcesContent":["/** ****************************************************************************\r\n * Spine Runtimes License Agreement\r\n * Last updated July 28, 2023. Replaces all prior versions.\r\n *\r\n * Copyright (c) 2013-2023, Esoteric Software LLC\r\n *\r\n * Integration of the Spine Runtimes into software or otherwise creating\r\n * derivative works of the Spine Runtimes is permitted under the terms and\r\n * conditions of Section 2 of the Spine Editor License Agreement:\r\n * http://esotericsoftware.com/spine-editor-license\r\n *\r\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\r\n * otherwise create derivative works of the Spine Runtimes (collectively,\r\n * \"Products\"), provided that each user of the Products must obtain their own\r\n * Spine Editor license and redistribution of the Products in any form must\r\n * include this license and copyright notice.\r\n *\r\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\r\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\r\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\r\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\ndeclare global\r\n{\r\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n    // @ts-ignore\r\n    // eslint-disable-next-line no-var\r\n    var require: any;\r\n    // eslint-disable-next-line no-var\r\n    var PIXI: any;\r\n}\r\n\r\nif (typeof window !== 'undefined' && window.PIXI)\r\n{\r\n    const prevRequire = window.require;\r\n\r\n    // eslint-disable-next-line consistent-return\r\n    (window as any).require = (x: string) =>\r\n    {\r\n        if (prevRequire) return prevRequire(x);\r\n        else if (x.startsWith('@pixi/') || x.startsWith('pixi.js')) return window.PIXI;\r\n    };\r\n}\r\n\r\nexport { };\r\n","/** ****************************************************************************\r\n * Spine Runtimes License Agreement\r\n * Last updated July 28, 2023. Replaces all prior versions.\r\n *\r\n * Copyright (c) 2013-2023, Esoteric Software LLC\r\n *\r\n * Integration of the Spine Runtimes into software or otherwise creating\r\n * derivative works of the Spine Runtimes is permitted under the terms and\r\n * conditions of Section 2 of the Spine Editor License Agreement:\r\n * http://esotericsoftware.com/spine-editor-license\r\n *\r\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\r\n * otherwise create derivative works of the Spine Runtimes (collectively,\r\n * \"Products\"), provided that each user of the Products must obtain their own\r\n * Spine Editor license and redistribution of the Products in any form must\r\n * include this license and copyright notice.\r\n *\r\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\r\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\r\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\r\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nimport { Texture as PixiTexture } from 'pixi.js';\r\nimport { BlendMode, Texture, TextureFilter, TextureWrap } from '@esotericsoftware/spine-core';\r\n\r\nimport type { BLEND_MODES, SCALE_MODE, TextureSource, WRAP_MODE } from 'pixi.js';\r\n\r\nexport class SpineTexture extends Texture\r\n{\r\n    private static readonly textureMap: Map<TextureSource, SpineTexture> = new Map<TextureSource, SpineTexture>();\r\n\r\n    public static from(texture: TextureSource): SpineTexture\r\n    {\r\n        if (SpineTexture.textureMap.has(texture))\r\n        {\r\n            return SpineTexture.textureMap.get(texture) as SpineTexture;\r\n        }\r\n\r\n        return new SpineTexture(texture);\r\n    }\r\n\r\n    public readonly texture: PixiTexture;\r\n\r\n    private constructor(image: TextureSource)\r\n    {\r\n        // Todo: maybe add error handling if you feed a video texture to spine?\r\n        super(image.resource);\r\n        this.texture = PixiTexture.from(image);\r\n    }\r\n\r\n    public setFilters(minFilter: TextureFilter, magFilter: TextureFilter): void\r\n    {\r\n        const style = this.texture.source.style;\r\n\r\n        style.minFilter = SpineTexture.toPixiTextureFilter(minFilter);\r\n        style.magFilter = SpineTexture.toPixiTextureFilter(magFilter);\r\n        this.texture.source.autoGenerateMipmaps = SpineTexture.toPixiMipMap(minFilter);\r\n        this.texture.source.updateMipmaps();\r\n    }\r\n\r\n    public setWraps(uWrap: TextureWrap, vWrap: TextureWrap): void\r\n    {\r\n        const style = this.texture.source.style;\r\n\r\n        style.addressModeU = SpineTexture.toPixiTextureWrap(uWrap);\r\n        style.addressModeV = SpineTexture.toPixiTextureWrap(vWrap);\r\n    }\r\n\r\n    public dispose(): void\r\n    {\r\n        // I am not entirely sure about this...\r\n        this.texture.destroy();\r\n    }\r\n\r\n    private static toPixiMipMap(filter: TextureFilter): boolean\r\n    {\r\n        switch (filter)\r\n        {\r\n            case TextureFilter.Nearest:\r\n            case TextureFilter.Linear:\r\n                return false;\r\n\r\n            case TextureFilter.MipMapNearestLinear:\r\n            case TextureFilter.MipMapNearestNearest:\r\n            case TextureFilter.MipMapLinearLinear: // TextureFilter.MipMapLinearLinear == TextureFilter.MipMap\r\n            case TextureFilter.MipMapLinearNearest:\r\n                return true;\r\n\r\n            default:\r\n                throw new Error(`Unknown texture filter: ${String(filter)}`);\r\n        }\r\n    }\r\n\r\n    private static toPixiTextureFilter(filter: TextureFilter): SCALE_MODE\r\n    {\r\n        switch (filter)\r\n        {\r\n            case TextureFilter.Nearest:\r\n            case TextureFilter.MipMapNearestLinear:\r\n            case TextureFilter.MipMapNearestNearest:\r\n                return 'nearest';\r\n\r\n            case TextureFilter.Linear:\r\n            case TextureFilter.MipMapLinearLinear: // TextureFilter.MipMapLinearLinear == TextureFilter.MipMap\r\n            case TextureFilter.MipMapLinearNearest:\r\n                return 'linear';\r\n\r\n            default:\r\n                throw new Error(`Unknown texture filter: ${String(filter)}`);\r\n        }\r\n    }\r\n\r\n    private static toPixiTextureWrap(wrap: TextureWrap): WRAP_MODE\r\n    {\r\n        switch (wrap)\r\n        {\r\n            case TextureWrap.ClampToEdge:\r\n                return 'clamp-to-edge';\r\n\r\n            case TextureWrap.MirroredRepeat:\r\n                return 'mirror-repeat';\r\n\r\n            case TextureWrap.Repeat:\r\n                return 'repeat';\r\n\r\n            default:\r\n                throw new Error(`Unknown texture wrap: ${String(wrap)}`);\r\n        }\r\n    }\r\n\r\n    public static toPixiBlending(blend: BlendMode): BLEND_MODES\r\n    {\r\n        switch (blend)\r\n        {\r\n            case BlendMode.Normal:\r\n                return 'normal';\r\n\r\n            case BlendMode.Additive:\r\n                return 'add';\r\n\r\n            case BlendMode.Multiply:\r\n                return 'multiply';\r\n\r\n            case BlendMode.Screen:\r\n                return 'screen';\r\n\r\n            default:\r\n                throw new Error(`Unknown blendMode: ${String(blend)}`);\r\n        }\r\n    }\r\n}\r\n","/** ****************************************************************************\r\n * Spine Runtimes License Agreement\r\n * Last updated July 28, 2023. Replaces all prior versions.\r\n *\r\n * Copyright (c) 2013-2023, Esoteric Software LLC\r\n *\r\n * Integration of the Spine Runtimes into software or otherwise creating\r\n * derivative works of the Spine Runtimes is permitted under the terms and\r\n * conditions of Section 2 of the Spine Editor License Agreement:\r\n * http://esotericsoftware.com/spine-editor-license\r\n *\r\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\r\n * otherwise create derivative works of the Spine Runtimes (collectively,\r\n * \"Products\"), provided that each user of the Products must obtain their own\r\n * Spine Editor license and redistribution of the Products in any form must\r\n * include this license and copyright notice.\r\n *\r\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\r\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\r\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\r\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nimport {\r\n    checkExtension,\r\n    DOMAdapter,\r\n    extensions,\r\n    ExtensionType,\r\n    LoaderParserPriority,\r\n    path,\r\n    TextureSource\r\n} from 'pixi.js';\r\nimport { SpineTexture } from '../SpineTexture';\r\nimport { TextureAtlas } from '@esotericsoftware/spine-core';\r\n\r\nimport type { AssetExtension, Loader, ResolvedAsset, Texture } from 'pixi.js';\r\n\r\ntype RawAtlas = string;\r\n\r\nconst spineTextureAtlasLoader: AssetExtension<RawAtlas | TextureAtlas, ISpineAtlasMetadata> = {\r\n    extension: ExtensionType.Asset,\r\n\r\n    loader: {\r\n        extension: {\r\n            type: ExtensionType.LoadParser,\r\n            priority: LoaderParserPriority.Normal,\r\n            name: 'spineTextureAtlasLoader',\r\n        },\r\n\r\n        test(url: string): boolean\r\n        {\r\n            return checkExtension(url, '.atlas');\r\n        },\r\n\r\n        async load(url: string): Promise<RawAtlas>\r\n        {\r\n            const response = await DOMAdapter.get().fetch(url);\r\n\r\n            const txt = await response.text();\r\n\r\n            return txt;\r\n        },\r\n\r\n        testParse(asset: unknown, options: ResolvedAsset): Promise<boolean>\r\n        {\r\n            const isExtensionRight = checkExtension(options.src as string, '.atlas');\r\n            const isString = typeof asset === 'string';\r\n\r\n            return Promise.resolve(isExtensionRight && isString);\r\n        },\r\n\r\n        unload(atlas: TextureAtlas)\r\n        {\r\n            atlas.dispose();\r\n        },\r\n\r\n        async parse(asset: RawAtlas, options: ResolvedAsset, loader: Loader): Promise<TextureAtlas>\r\n        {\r\n            const metadata: ISpineAtlasMetadata = options.data || {};\r\n            let basePath = path.dirname(options.src as string);\r\n\r\n            if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1)\r\n            {\r\n                basePath += '/';\r\n            }\r\n\r\n            // Retval is going to be a texture atlas. However we need to wait for it's callback to resolve this promise.\r\n            const retval = new TextureAtlas(asset);\r\n\r\n            // If the user gave me only one texture, that one is assumed to be the \"first\" texture in the atlas\r\n            if (metadata.images instanceof TextureSource || typeof metadata.images === 'string')\r\n            {\r\n                const pixiTexture = metadata.images;\r\n\r\n                metadata.images = {} as Record<string, TextureSource | string>;\r\n                metadata.images[retval.pages[0].name] = pixiTexture;\r\n            }\r\n\r\n            // we will wait for all promises for the textures at the same time at the end.\r\n            const textureLoadingPromises:Promise<any>[] = [];\r\n\r\n            // fill the pages\r\n            for (const page of retval.pages)\r\n            {\r\n                const pageName = page.name;\r\n                const providedPage = metadata?.images ? metadata.images[pageName] : undefined;\r\n\r\n                if (providedPage instanceof TextureSource)\r\n                {\r\n                    page.setTexture(SpineTexture.from(providedPage));\r\n                }\r\n                else\r\n                {\r\n                    // eslint-disable-next-line max-len\r\n                    const url: string = providedPage ?? path.normalize([...basePath.split(path.sep), pageName].join(path.sep));\r\n\r\n                    const assetsToLoadIn = {\r\n                        src: url,\r\n                        data: {\r\n                            ...metadata.imageMetadata,\r\n                            alphaMode: page.pma ? 'premultiplied-alpha' : 'premultiply-alpha-on-upload'\r\n                        }\r\n                    };\r\n\r\n                    const pixiPromise = loader.load<Texture>(assetsToLoadIn).then((texture) =>\r\n                    {\r\n                        page.setTexture(SpineTexture.from(texture.source));\r\n                    });\r\n\r\n                    textureLoadingPromises.push(pixiPromise);\r\n                }\r\n            }\r\n\r\n            await Promise.all(textureLoadingPromises);\r\n\r\n            return retval;\r\n        },\r\n    },\r\n} as AssetExtension<RawAtlas | TextureAtlas, ISpineAtlasMetadata>;\r\n\r\nextensions.add(spineTextureAtlasLoader);\r\n\r\nexport interface ISpineAtlasMetadata\r\n{\r\n    // If you are downloading an .atlas file, this metadata will go to the Texture loader\r\n    imageMetadata?: any;\r\n    // If you already have atlas pages loaded as pixi textures\r\n    // and want to use that to create the atlas, you can pass them here\r\n    images?: TextureSource | string | Record<string, TextureSource | string>;\r\n}\r\n","/** ****************************************************************************\r\n * Spine Runtimes License Agreement\r\n * Last updated July 28, 2023. Replaces all prior versions.\r\n *\r\n * Copyright (c) 2013-2023, Esoteric Software LLC\r\n *\r\n * Integration of the Spine Runtimes into software or otherwise creating\r\n * derivative works of the Spine Runtimes is permitted under the terms and\r\n * conditions of Section 2 of the Spine Editor License Agreement:\r\n * http://esotericsoftware.com/spine-editor-license\r\n *\r\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\r\n * otherwise create derivative works of the Spine Runtimes (collectively,\r\n * \"Products\"), provided that each user of the Products must obtain their own\r\n * Spine Editor license and redistribution of the Products in any form must\r\n * include this license and copyright notice.\r\n *\r\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\r\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\r\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\r\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nimport {\r\n    type AssetExtension,\r\n    checkExtension,\r\n    DOMAdapter,\r\n    extensions,\r\n    ExtensionType,\r\n    LoaderParserPriority,\r\n    ResolvedAsset\r\n} from 'pixi.js';\r\n\r\ntype SkeletonJsonAsset = any;\r\ntype SkeletonBinaryAsset = Uint8Array;\r\n\r\nfunction isJson(resource: any): resource is SkeletonJsonAsset\r\n{\r\n    return Object.prototype.hasOwnProperty.call(resource, 'bones');\r\n}\r\n\r\nfunction isBuffer(resource: any): resource is SkeletonBinaryAsset\r\n{\r\n    return resource instanceof Uint8Array;\r\n}\r\n\r\nconst spineLoaderExtension: AssetExtension<SkeletonJsonAsset | SkeletonBinaryAsset> = {\r\n    extension: ExtensionType.Asset,\r\n\r\n    loader: {\r\n        extension: {\r\n            type: ExtensionType.LoadParser,\r\n            priority: LoaderParserPriority.Normal,\r\n            name: 'spineSkeletonLoader',\r\n        },\r\n\r\n        test(url)\r\n        {\r\n            return checkExtension(url, '.skel');\r\n        },\r\n\r\n        async load(url: string): Promise<SkeletonBinaryAsset>\r\n        {\r\n            const response = await DOMAdapter.get().fetch(url);\r\n\r\n            const buffer = new Uint8Array(await response.arrayBuffer());\r\n\r\n            return buffer;\r\n        },\r\n        testParse(asset: unknown, options: ResolvedAsset): Promise<boolean>\r\n        {\r\n            const isJsonSpineModel = checkExtension(options.src, '.json') && isJson(asset);\r\n            const isBinarySpineModel = checkExtension(options.src, '.skel') && isBuffer(asset);\r\n\r\n            return Promise.resolve(isJsonSpineModel || isBinarySpineModel);\r\n        },\r\n    },\r\n} as AssetExtension<SkeletonJsonAsset | SkeletonBinaryAsset>;\r\n\r\nextensions.add(spineLoaderExtension);\r\n","import { Buffer, BufferUsage, Geometry } from 'pixi.js';\r\n\r\nconst placeHolderBufferData = new Float32Array(1);\r\nconst placeHolderIndexData = new Uint32Array(1);\r\n\r\nexport class DarkTintBatchGeometry extends Geometry\r\n{\r\n    constructor()\r\n    {\r\n        const vertexSize = 7;\r\n\r\n        const attributeBuffer = new Buffer({\r\n            data: placeHolderBufferData,\r\n            label: 'attribute-batch-buffer',\r\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\r\n            shrinkToFit: false,\r\n        });\r\n\r\n        const indexBuffer = new Buffer({\r\n            data: placeHolderIndexData,\r\n            label: 'index-batch-buffer',\r\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST, // | BufferUsage.STATIC,\r\n            shrinkToFit: false,\r\n        });\r\n\r\n        const stride = vertexSize * 4;\r\n\r\n        super({\r\n            attributes: {\r\n                aPosition: {\r\n                    buffer: attributeBuffer,\r\n                    format: 'float32x2',\r\n                    stride,\r\n                    offset: 0,\r\n                },\r\n                aUV: {\r\n                    buffer: attributeBuffer,\r\n                    format: 'float32x2',\r\n                    stride,\r\n                    offset: 2 * 4,\r\n                },\r\n                aColor: {\r\n                    buffer: attributeBuffer,\r\n                    format: 'unorm8x4',\r\n                    stride,\r\n                    offset: 4 * 4,\r\n                },\r\n                aDarkColor: {\r\n                    buffer: attributeBuffer,\r\n                    format: 'unorm8x4',\r\n                    stride,\r\n                    offset: 5 * 4,\r\n                },\r\n                aTextureIdAndRound: {\r\n                    buffer: attributeBuffer,\r\n                    format: 'uint16x2',\r\n                    stride,\r\n                    offset: 6 * 4,\r\n                },\r\n            },\r\n            indexBuffer\r\n        });\r\n    }\r\n}\r\n\r\n","/* eslint-disable max-len */\r\nexport const darkTintBit = {\r\n    name: 'color-bit',\r\n    vertex: {\r\n        header: /* wgsl */`\r\n            @in aDarkColor: vec4<f32>;\r\n            @out vDarkColor: vec4<f32>;\r\n        `,\r\n        main: /* wgsl */`\r\n        vDarkColor = aDarkColor;\r\n        `\r\n    },\r\n    fragment: {\r\n        header: /* wgsl */`\r\n            @in vDarkColor: vec4<f32>;\r\n        `,\r\n        end: /* wgsl */`\r\n            \r\n        let alpha = outColor.a * vColor.a;\r\n        let rgb = ((outColor.a - 1.0) * vDarkColor.a + 1.0 - outColor.rgb) * vDarkColor.rgb + outColor.rgb * vColor.rgb;\r\n\r\n        finalColor = vec4<f32>(rgb, alpha);\r\n\r\n        `\r\n    }\r\n};\r\n\r\nexport const darkTintBitGl = {\r\n    name: 'color-bit',\r\n    vertex: {\r\n        header: /* glsl */`\r\n            in vec4 aDarkColor;\r\n            out vec4 vDarkColor;\r\n        `,\r\n        main: /* glsl */`\r\n            vDarkColor = aDarkColor;\r\n        `\r\n    },\r\n    fragment: {\r\n        header: /* glsl */`\r\n            in vec4 vDarkColor;\r\n        `,\r\n        end: /* glsl */`\r\n            \r\n        finalColor.a = outColor.a * vColor.a;\r\n        finalColor.rgb = ((outColor.a - 1.0) * vDarkColor.a + 1.0 - outColor.rgb) * vDarkColor.rgb + outColor.rgb * vColor.rgb;\r\n        `\r\n    }\r\n};\r\n","import {\r\n    colorBit,\r\n    colorBitGl,\r\n    compileHighShaderGlProgram,\r\n    compileHighShaderGpuProgram,\r\n    generateTextureBatchBit,\r\n    generateTextureBatchBitGl,\r\n    getBatchSamplersUniformGroup,\r\n    roundPixelsBit,\r\n    roundPixelsBitGl,\r\n    Shader\r\n} from 'pixi.js';\r\nimport { darkTintBit, darkTintBitGl } from './darkTintBit';\r\n\r\nexport class DarkTintShader extends Shader\r\n{\r\n    constructor(maxTextures: number)\r\n    {\r\n        const glProgram = compileHighShaderGlProgram({\r\n            name: 'dark-tint-batch',\r\n            bits: [\r\n                colorBitGl,\r\n                darkTintBitGl,\r\n                generateTextureBatchBitGl(maxTextures),\r\n                roundPixelsBitGl,\r\n            ]\r\n        });\r\n\r\n        const gpuProgram = compileHighShaderGpuProgram({\r\n            name: 'dark-tint-batch',\r\n            bits: [\r\n                colorBit,\r\n                darkTintBit,\r\n                generateTextureBatchBit(maxTextures),\r\n                roundPixelsBit,\r\n            ]\r\n        });\r\n\r\n        super({\r\n            glProgram,\r\n            gpuProgram,\r\n            resources: {\r\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\r\n            }\r\n        });\r\n    }\r\n}\r\n","import {\r\n    Batcher,\r\n    Color,\r\n    DefaultBatchableMeshElement,\r\n    DefaultBatchableQuadElement,\r\n    extensions,\r\n    ExtensionType,\r\n    Shader\r\n} from 'pixi.js';\r\nimport { DarkTintBatchGeometry } from './DarkTintBatchGeometry';\r\nimport { DarkTintShader } from './DarkTintShader';\r\n\r\nlet defaultShader: Shader = null;\r\n\r\n/** The default batcher is used to batch quads and meshes. */\r\nexport class DarkTintBatcher extends Batcher\r\n{\r\n    /** @ignore */\r\n    public static extension = {\r\n        type: [\r\n            ExtensionType.Batcher,\r\n        ],\r\n        name: 'darkTint',\r\n    } as const;\r\n\r\n    public geometry = new DarkTintBatchGeometry();\r\n    public shader = defaultShader || (defaultShader = new DarkTintShader(this.maxTextures));\r\n    public name = DarkTintBatcher.extension.name;\r\n\r\n    /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, darkColor, textureIdAndRound -> total = 7 */\r\n    public vertexSize = 7;\r\n\r\n    public packAttributes(\r\n        element: DefaultBatchableMeshElement & { darkColor: number },\r\n        float32View: Float32Array,\r\n        uint32View: Uint32Array,\r\n        index: number,\r\n        textureId: number\r\n    )\r\n    {\r\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\r\n\r\n        const wt = element.transform;\r\n\r\n        const a = wt.a;\r\n        const b = wt.b;\r\n        const c = wt.c;\r\n        const d = wt.d;\r\n        const tx = wt.tx;\r\n        const ty = wt.ty;\r\n\r\n        const { positions, uvs } = element;\r\n\r\n        const argb = element.color;\r\n        const worldAlpha = ((argb >> 24) & 0xFF) / 255;\r\n        const darkColor = Color.shared.setValue(element.darkColor).premultiply(worldAlpha, true).toPremultiplied(1, false);\r\n\r\n        const offset = element.attributeOffset;\r\n        const end = offset + element.attributeSize;\r\n\r\n        for (let i = offset; i < end; i++)\r\n        {\r\n            const i2 = i * 2;\r\n\r\n            const x = positions[i2];\r\n            const y = positions[(i2) + 1];\r\n\r\n            float32View[index++] = (a * x) + (c * y) + tx;\r\n            float32View[index++] = (d * y) + (b * x) + ty;\r\n\r\n            float32View[index++] = uvs[i2];\r\n            float32View[index++] = uvs[(i2) + 1];\r\n\r\n            uint32View[index++] = argb;\r\n            uint32View[index++] = darkColor;\r\n\r\n            uint32View[index++] = textureIdAndRound;\r\n        }\r\n    }\r\n\r\n    public packQuadAttributes(\r\n        element: DefaultBatchableQuadElement & { darkColor: number },\r\n        float32View: Float32Array,\r\n        uint32View: Uint32Array,\r\n        index: number,\r\n        textureId: number\r\n    )\r\n    {\r\n        const texture = element.texture;\r\n\r\n        const wt = element.transform;\r\n\r\n        const a = wt.a;\r\n        const b = wt.b;\r\n        const c = wt.c;\r\n        const d = wt.d;\r\n        const tx = wt.tx;\r\n        const ty = wt.ty;\r\n\r\n        const bounds = element.bounds;\r\n\r\n        const w0 = bounds.maxX;\r\n        const w1 = bounds.minX;\r\n        const h0 = bounds.maxY;\r\n        const h1 = bounds.minY;\r\n\r\n        const uvs = texture.uvs;\r\n\r\n        // _ _ _ _\r\n        // a b g r\r\n        const argb = element.color;\r\n        const darkColor = element.darkColor;\r\n\r\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\r\n\r\n        float32View[index + 0] = (a * w1) + (c * h1) + tx;\r\n        float32View[index + 1] = (d * h1) + (b * w1) + ty;\r\n\r\n        float32View[index + 2] = uvs.x0;\r\n        float32View[index + 3] = uvs.y0;\r\n\r\n        uint32View[index + 4] = argb;\r\n        uint32View[index + 5] = darkColor;\r\n        uint32View[index + 6] = textureIdAndRound;\r\n\r\n        // xy\r\n        float32View[index + 7] = (a * w0) + (c * h1) + tx;\r\n        float32View[index + 8] = (d * h1) + (b * w0) + ty;\r\n\r\n        float32View[index + 9] = uvs.x1;\r\n        float32View[index + 10] = uvs.y1;\r\n\r\n        uint32View[index + 11] = argb;\r\n        uint32View[index + 12] = darkColor;\r\n        uint32View[index + 13] = textureIdAndRound;\r\n\r\n        // xy\r\n        float32View[index + 14] = (a * w0) + (c * h0) + tx;\r\n        float32View[index + 15] = (d * h0) + (b * w0) + ty;\r\n\r\n        float32View[index + 16] = uvs.x2;\r\n        float32View[index + 17] = uvs.y2;\r\n\r\n        uint32View[index + 18] = argb;\r\n        uint32View[index + 19] = darkColor;\r\n        uint32View[index + 20] = textureIdAndRound;\r\n\r\n        // xy\r\n        float32View[index + 21] = (a * w1) + (c * h0) + tx;\r\n        float32View[index + 22] = (d * h0) + (b * w1) + ty;\r\n\r\n        float32View[index + 23] = uvs.x3;\r\n        float32View[index + 24] = uvs.y3;\r\n\r\n        uint32View[index + 25] = argb;\r\n        uint32View[index + 26] = darkColor;\r\n        uint32View[index + 27] = textureIdAndRound;\r\n    }\r\n}\r\n\r\nextensions.add(DarkTintBatcher);\r\n","/** ****************************************************************************\r\n * Spine Runtimes License Agreement\r\n * Last updated July 28, 2023. Replaces all prior versions.\r\n *\r\n * Copyright (c) 2013-2023, Esoteric Software LLC\r\n *\r\n * Integration of the Spine Runtimes into software or otherwise creating\r\n * derivative works of the Spine Runtimes is permitted under the terms and\r\n * conditions of Section 2 of the Spine Editor License Agreement:\r\n * http://esotericsoftware.com/spine-editor-license\r\n *\r\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\r\n * otherwise create derivative works of the Spine Runtimes (collectively,\r\n * \"Products\"), provided that each user of the Products must obtain their own\r\n * Spine Editor license and redistribution of the Products in any form must\r\n * include this license and copyright notice.\r\n *\r\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\r\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\r\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\r\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nimport { AttachmentCacheData, Spine } from './Spine';\r\n\r\nimport type { Batch, Batcher, BLEND_MODES, DefaultBatchableMeshElement, Matrix, Texture } from 'pixi.js';\r\n\r\nexport class BatchableSpineSlot implements DefaultBatchableMeshElement\r\n{\r\n    indexOffset = 0;\r\n    attributeOffset = 0;\r\n\r\n    indexSize: number;\r\n    attributeSize: number;\r\n\r\n    batcherName = 'darkTint';\r\n\r\n    readonly packAsQuad = false;\r\n\r\n    renderable: Spine;\r\n\r\n    positions: Float32Array;\r\n    indices: number[] | Uint16Array;\r\n    uvs: Float32Array;\r\n\r\n    roundPixels: 0 | 1;\r\n    data: AttachmentCacheData;\r\n    blendMode: BLEND_MODES;\r\n\r\n    darkTint: number;\r\n\r\n    texture: Texture;\r\n\r\n    transform: Matrix;\r\n\r\n    // used internally by batcher specific..\r\n    // stored for efficient updating..\r\n    _textureId: number;\r\n    _attributeStart: number;\r\n    _indexStart: number;\r\n    _batcher: Batcher;\r\n    _batch: Batch;\r\n\r\n    get color()\r\n    {\r\n        const slotColor = this.data.color;\r\n\r\n        const parentColor:number = this.renderable.groupColor;\r\n        const parentAlpha:number = this.renderable.groupAlpha;\r\n        let abgr:number;\r\n\r\n        const mixedA = (slotColor.a * parentAlpha) * 255;\r\n\r\n        if (parentColor !== 0xFFFFFF)\r\n        {\r\n            const parentB = (parentColor >> 16) & 0xFF;\r\n            const parentG = (parentColor >> 8) & 0xFF;\r\n            const parentR = parentColor & 0xFF;\r\n\r\n            const mixedR = (slotColor.r * parentR);\r\n            const mixedG = (slotColor.g * parentG);\r\n            const mixedB = (slotColor.b * parentB);\r\n\r\n            abgr = ((mixedA) << 24) | (mixedB << 16) | (mixedG << 8) | mixedR;\r\n        }\r\n        else\r\n        {\r\n            abgr = ((mixedA) << 24) | ((slotColor.b * 255) << 16) | ((slotColor.g * 255) << 8) | (slotColor.r * 255);\r\n        }\r\n\r\n        return abgr;\r\n    }\r\n\r\n    get darkColor()\r\n    {\r\n        const darkColor = this.data.darkColor;\r\n\r\n        return ((darkColor.b * 255) << 16) | ((darkColor.g * 255) << 8) | (darkColor.r * 255);\r\n    }\r\n\r\n    get groupTransform() { return this.renderable.groupTransform; }\r\n\r\n    setData(\r\n        renderable:Spine,\r\n        data:AttachmentCacheData,\r\n        blendMode:BLEND_MODES,\r\n        roundPixels: 0 | 1)\r\n    {\r\n        this.renderable = renderable;\r\n        this.transform = renderable.groupTransform;\r\n        this.data = data;\r\n\r\n        if (data.clipped)\r\n        {\r\n            const clippedData = data.clippedData;\r\n\r\n            this.indexSize = clippedData.indicesCount;\r\n            this.attributeSize = clippedData.vertexCount;\r\n            this.positions = clippedData.vertices;\r\n            this.indices = clippedData.indices;\r\n            this.uvs = clippedData.uvs;\r\n        }\r\n        else\r\n        {\r\n            this.indexSize = data.indices.length;\r\n            this.attributeSize = data.vertices.length / 2;\r\n            this.positions = data.vertices;\r\n            this.indices = data.indices;\r\n            this.uvs = data.uvs;\r\n        }\r\n\r\n        this.texture = data.texture;\r\n        this.roundPixels = roundPixels;\r\n\r\n        this.blendMode = blendMode;\r\n\r\n        this.batcherName = data.darkTint ? 'darkTint' : 'default';\r\n    }\r\n}\r\n","/** ****************************************************************************\r\n * Spine Runtimes License Agreement\r\n * Last updated July 28, 2023. Replaces all prior versions.\r\n *\r\n * Copyright (c) 2013-2023, Esoteric Software LLC\r\n *\r\n * Integration of the Spine Runtimes into software or otherwise creating\r\n * derivative works of the Spine Runtimes is permitted under the terms and\r\n * conditions of Section 2 of the Spine Editor License Agreement:\r\n * http://esotericsoftware.com/spine-editor-license\r\n *\r\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\r\n * otherwise create derivative works of the Spine Runtimes (collectively,\r\n * \"Products\"), provided that each user of the Products must obtain their own\r\n * Spine Editor license and redistribution of the Products in any form must\r\n * include this license and copyright notice.\r\n *\r\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\r\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\r\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\r\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nimport {\r\n    collectAllRenderables,\r\n    extensions, ExtensionType,\r\n    InstructionSet,\r\n    type Renderer,\r\n    type RenderPipe,\r\n} from 'pixi.js';\r\nimport { BatchableSpineSlot } from './BatchableSpineSlot';\r\nimport { Spine } from './Spine';\r\nimport { MeshAttachment, RegionAttachment, SkeletonClipping } from '@esotericsoftware/spine-core';\r\n\r\nconst clipper = new SkeletonClipping();\r\n\r\nconst spineBlendModeMap = {\r\n    0: 'normal',\r\n    1: 'add',\r\n    2: 'multiply',\r\n    3: 'screen'\r\n};\r\n\r\n// eslint-disable-next-line max-len\r\nexport class SpinePipe implements RenderPipe<Spine>\r\n{\r\n    /** @ignore */\r\n    static extension = {\r\n        type: [\r\n            ExtensionType.WebGLPipes,\r\n            ExtensionType.WebGPUPipes,\r\n            ExtensionType.CanvasPipes,\r\n        ],\r\n        name: 'spine',\r\n    } as const;\r\n\r\n    renderer: Renderer;\r\n\r\n    private gpuSpineData:Record<string, any> = {};\r\n\r\n    constructor(renderer: Renderer)\r\n    {\r\n        this.renderer = renderer;\r\n    }\r\n\r\n    validateRenderable(spine: Spine): boolean\r\n    {\r\n        spine._applyState();\r\n\r\n        // if pine attachments have changed, we need to rebuild the batch!\r\n        if (spine.spineAttachmentsDirty)\r\n        {\r\n            return true;\r\n        }\r\n        // if the textures have changed, we need to rebuild the batch, but only if the texture is not already in the batch\r\n        else if (spine.spineTexturesDirty)\r\n        {\r\n            // loop through and see if the textures have changed..\r\n            const drawOrder = spine.skeleton.drawOrder;\r\n            const gpuSpine = this.gpuSpineData[spine.uid];\r\n\r\n            for (let i = 0, n = drawOrder.length; i < n; i++)\r\n            {\r\n                const slot = drawOrder[i];\r\n                const attachment = slot.getAttachment();\r\n\r\n                if (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment)\r\n                {\r\n                    const cacheData = spine._getCachedData(slot, attachment);\r\n                    const batchableSpineSlot = gpuSpine.slotBatches?.[cacheData.id];\r\n\r\n                    const texture = cacheData.texture;\r\n\r\n                    if (batchableSpineSlot && texture !== batchableSpineSlot?.texture)\r\n                    {\r\n                        if (!batchableSpineSlot._batcher.checkAndUpdateTexture(batchableSpineSlot, texture))\r\n                        {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    addRenderable(spine: Spine, instructionSet:InstructionSet)\r\n    {\r\n        const gpuSpine = this.gpuSpineData[spine.uid] ||= { slotBatches: {} };\r\n\r\n        const batcher = this.renderer.renderPipes.batch;\r\n\r\n        const drawOrder = spine.skeleton.drawOrder;\r\n\r\n        const roundPixels = (this.renderer._roundPixels | spine._roundPixels) as 0 | 1;\r\n\r\n        spine._applyState();\r\n\r\n        for (let i = 0, n = drawOrder.length; i < n; i++)\r\n        {\r\n            const slot = drawOrder[i];\r\n            const attachment = slot.getAttachment();\r\n            const blendMode = spineBlendModeMap[slot.data.blendMode];\r\n\r\n            if (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment)\r\n            {\r\n                const cacheData = spine._getCachedData(slot, attachment);\r\n                const batchableSpineSlot = gpuSpine.slotBatches[cacheData.id] ||= new BatchableSpineSlot();\r\n\r\n                batchableSpineSlot.setData(\r\n                    spine,\r\n                    cacheData,\r\n                    blendMode,\r\n                    roundPixels\r\n                );\r\n\r\n                if (!cacheData.skipRender)\r\n                {\r\n                    batcher.addToBatch(batchableSpineSlot, instructionSet);\r\n                }\r\n            }\r\n\r\n            const containerAttachment = spine._slotsObject[slot.data.name];\r\n\r\n            if (containerAttachment)\r\n            {\r\n                const container = containerAttachment.container;\r\n\r\n                container.includeInBuild = true;\r\n                collectAllRenderables(container, instructionSet, this.renderer);\r\n                container.includeInBuild = false;\r\n            }\r\n        }\r\n\r\n        clipper.clipEnd();\r\n    }\r\n\r\n    updateRenderable(spine: Spine)\r\n    {\r\n        // we assume that spine will always change its verts size..\r\n        const gpuSpine = this.gpuSpineData[spine.uid];\r\n\r\n        spine._applyState();\r\n\r\n        const drawOrder = spine.skeleton.drawOrder;\r\n\r\n        for (let i = 0, n = drawOrder.length; i < n; i++)\r\n        {\r\n            const slot = drawOrder[i];\r\n            const attachment = slot.getAttachment();\r\n\r\n            if (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment)\r\n            {\r\n                const cacheData = spine._getCachedData(slot, attachment);\r\n\r\n                if (!cacheData.skipRender)\r\n                {\r\n                    const batchableSpineSlot = gpuSpine.slotBatches[spine._getCachedData(slot, attachment).id];\r\n\r\n                    batchableSpineSlot?._batcher?.updateElement(batchableSpineSlot);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    destroyRenderable(spine: Spine)\r\n    {\r\n        // TODO remove the renderable from the batcher\r\n        this.gpuSpineData[spine.uid] = null as any;\r\n    }\r\n\r\n    destroy()\r\n    {\r\n        this.gpuSpineData = null as any;\r\n        this.renderer = null as any;\r\n    }\r\n}\r\n\r\nextensions.add(SpinePipe);\r\n","/** ****************************************************************************\r\n * Spine Runtimes License Agreement\r\n * Last updated July 28, 2023. Replaces all prior versions.\r\n *\r\n * Copyright (c) 2013-2023, Esoteric Software LLC\r\n *\r\n * Integration of the Spine Runtimes into software or otherwise creating\r\n * derivative works of the Spine Runtimes is permitted under the terms and\r\n * conditions of Section 2 of the Spine Editor License Agreement:\r\n * http://esotericsoftware.com/spine-editor-license\r\n *\r\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\r\n * otherwise create derivative works of the Spine Runtimes (collectively,\r\n * \"Products\"), provided that each user of the Products must obtain their own\r\n * Spine Editor license and redistribution of the Products in any form must\r\n * include this license and copyright notice.\r\n *\r\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\r\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\r\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\r\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nimport {\r\n    Assets,\r\n    Bounds,\r\n    Cache,\r\n    Container,\r\n    ContainerOptions,\r\n    DEG_TO_RAD,\r\n    DestroyOptions,\r\n    PointData,\r\n    Texture,\r\n    Ticker,\r\n    ViewContainer,\r\n} from 'pixi.js';\r\nimport { ISpineDebugRenderer } from './SpineDebugRenderer';\r\nimport {\r\n    AnimationState,\r\n    AnimationStateData,\r\n    AtlasAttachmentLoader,\r\n    Attachment,\r\n    Bone,\r\n    ClippingAttachment,\r\n    Color,\r\n    MeshAttachment,\r\n    Physics,\r\n    RegionAttachment,\r\n    Skeleton,\r\n    SkeletonBinary,\r\n    SkeletonBounds,\r\n    SkeletonClipping,\r\n    SkeletonData,\r\n    SkeletonJson,\r\n    Slot,\r\n    type TextureAtlas,\r\n    TrackEntry,\r\n    Vector2,\r\n} from '@esotericsoftware/spine-core';\r\n\r\nexport type SpineFromOptions = {\r\n    skeleton: string;\r\n    atlas: string;\r\n    scale?: number;\r\n};\r\n\r\nconst vectorAux = new Vector2();\r\nconst lightColor = new Color();\r\nconst darkColor = new Color();\r\n\r\nSkeleton.yDown = true;\r\n\r\nconst clipper = new SkeletonClipping();\r\n\r\nexport interface SpineOptions extends ContainerOptions\r\n{\r\n    skeletonData: SkeletonData;\r\n    autoUpdate?: boolean;\r\n}\r\n\r\nexport interface SpineEvents\r\n{\r\n    complete: [trackEntry: TrackEntry];\r\n    dispose: [trackEntry: TrackEntry];\r\n    end: [trackEntry: TrackEntry];\r\n    event: [trackEntry: TrackEntry, event: Event];\r\n    interrupt: [trackEntry: TrackEntry];\r\n    start: [trackEntry: TrackEntry];\r\n}\r\n\r\nexport interface AttachmentCacheData\r\n{\r\n    id: string;\r\n    clipped: boolean;\r\n    vertices: Float32Array;\r\n    uvs: Float32Array;\r\n    indices: number[];\r\n    color: Color;\r\n    darkColor: Color | null;\r\n    darkTint: boolean;\r\n    skipRender: boolean;\r\n    texture: Texture;\r\n    clippedData?: {\r\n        vertices: Float32Array;\r\n        uvs: Float32Array;\r\n        indices: Uint16Array;\r\n        vertexCount: number;\r\n        indicesCount: number;\r\n    };\r\n}\r\n\r\nexport class Spine extends ViewContainer\r\n{\r\n    // Pixi properties\r\n    public batched = true;\r\n    public buildId = 0;\r\n    public override readonly renderPipeId = 'spine';\r\n    public _didSpineUpdate = false;\r\n\r\n    public beforeUpdateWorldTransforms: (object: Spine) => void = () => { /** */ };\r\n    public afterUpdateWorldTransforms: (object: Spine) => void = () => { /** */ };\r\n\r\n    // Spine properties\r\n    public skeleton: Skeleton;\r\n    public state: AnimationState;\r\n    public skeletonBounds: SkeletonBounds;\r\n    private _debug?: ISpineDebugRenderer | undefined = undefined;\r\n\r\n    readonly _slotsObject: Record<string, {slot:Slot, container:Container}> = Object.create(null);\r\n\r\n    private getSlotFromRef(slotRef: number | string | Slot): Slot\r\n    {\r\n        let slot: Slot | null;\r\n\r\n        if (typeof slotRef === 'number') slot = this.skeleton.slots[slotRef];\r\n        else if (typeof slotRef === 'string') slot = this.skeleton.findSlot(slotRef);\r\n        else slot = slotRef;\r\n\r\n        if (!slot) throw new Error(`No slot found with the given slot reference: ${slotRef}`);\r\n\r\n        return slot;\r\n    }\r\n\r\n    public spineAttachmentsDirty = true;\r\n    public spineTexturesDirty = true;\r\n\r\n    private _lastAttachments: Attachment[];\r\n\r\n    private _stateChanged = true;\r\n    private attachmentCacheData: Record<string, AttachmentCacheData>[] = [];\r\n\r\n    public get debug(): ISpineDebugRenderer | undefined\r\n    {\r\n        return this._debug;\r\n    }\r\n\r\n    public set debug(value: ISpineDebugRenderer | undefined)\r\n    {\r\n        if (this._debug)\r\n        {\r\n            this._debug.unregisterSpine(this);\r\n        }\r\n        if (value)\r\n        {\r\n            value.registerSpine(this);\r\n        }\r\n        this._debug = value;\r\n    }\r\n\r\n    private autoUpdateWarned = false;\r\n    private _autoUpdate = true;\r\n\r\n    public get autoUpdate(): boolean\r\n    {\r\n        return this._autoUpdate;\r\n    }\r\n\r\n    public set autoUpdate(value: boolean)\r\n    {\r\n        if (value)\r\n        {\r\n            Ticker.shared.add(this.internalUpdate, this);\r\n            this.autoUpdateWarned = false;\r\n        }\r\n        else\r\n        {\r\n            Ticker.shared.remove(this.internalUpdate, this);\r\n        }\r\n\r\n        this._autoUpdate = value;\r\n    }\r\n\r\n    constructor(options: SpineOptions | SkeletonData)\r\n    {\r\n        if (options instanceof SkeletonData)\r\n        {\r\n            options = {\r\n                skeletonData: options,\r\n            };\r\n        }\r\n\r\n        super();\r\n\r\n        const skeletonData = options instanceof SkeletonData ? options : options.skeletonData;\r\n\r\n        this.skeleton = new Skeleton(skeletonData);\r\n        this.state = new AnimationState(new AnimationStateData(skeletonData));\r\n        this.autoUpdate = options?.autoUpdate ?? true;\r\n\r\n        const slots = this.skeleton.slots;\r\n\r\n        for (let i = 0; i < slots.length; i++)\r\n        {\r\n            this.attachmentCacheData[i] = Object.create(null);\r\n        }\r\n\r\n        this._updateState(0);\r\n    }\r\n\r\n    public update(dt: number): void\r\n    {\r\n        if (this.autoUpdate && !this.autoUpdateWarned)\r\n        {\r\n            console.warn(\r\n                // eslint-disable-next-line max-len\r\n                'You are calling update on a Spine instance that has autoUpdate set to true. This is probably not what you want.',\r\n            );\r\n            this.autoUpdateWarned = true;\r\n        }\r\n\r\n        this.internalUpdate(0, dt);\r\n    }\r\n\r\n    protected internalUpdate(_deltaFrame: any, deltaSeconds?: number): void\r\n    {\r\n        // Because reasons, pixi uses deltaFrames at 60fps.\r\n        // We ignore the default deltaFrames and use the deltaSeconds from pixi ticker.\r\n        this._updateState(deltaSeconds ?? Ticker.shared.deltaMS / 1000);\r\n    }\r\n\r\n    get bounds()\r\n    {\r\n        if (this._boundsDirty)\r\n        {\r\n            this.updateBounds();\r\n        }\r\n\r\n        return this._bounds;\r\n    }\r\n\r\n    public setBonePosition(bone: string | Bone, position: PointData): void\r\n    {\r\n        const boneAux = bone;\r\n\r\n        if (typeof bone === 'string')\r\n        {\r\n            bone = this.skeleton.findBone(bone) as Bone;\r\n        }\r\n\r\n        if (!bone) throw Error(`Cant set bone position, bone ${String(boneAux)} not found`);\r\n        vectorAux.set(position.x, position.y);\r\n\r\n        if (bone.parent)\r\n        {\r\n            const aux = bone.parent.worldToLocal(vectorAux);\r\n\r\n            bone.x = aux.x;\r\n            bone.y = -aux.y;\r\n        }\r\n        else\r\n        {\r\n            bone.x = vectorAux.x;\r\n            bone.y = vectorAux.y;\r\n        }\r\n    }\r\n\r\n    public getBonePosition(bone: string | Bone, outPos?: PointData): PointData | undefined\r\n    {\r\n        const boneAux = bone;\r\n\r\n        if (typeof bone === 'string')\r\n        {\r\n            bone = this.skeleton.findBone(bone) as Bone;\r\n        }\r\n\r\n        if (!bone)\r\n        {\r\n            console.error(`Cant set bone position! Bone ${String(boneAux)} not found`);\r\n\r\n            return outPos;\r\n        }\r\n\r\n        if (!outPos)\r\n        {\r\n            outPos = { x: 0, y: 0 };\r\n        }\r\n\r\n        outPos.x = bone.worldX;\r\n        outPos.y = bone.worldY;\r\n\r\n        return outPos;\r\n    }\r\n\r\n    /**\r\n     * Will update the state based on the specified time, this will not apply the state to the skeleton\r\n     * as this is differed until the `applyState` method is called.\r\n     *\r\n     * @param time the time at which to set the state\r\n     * @internal\r\n     */\r\n    _updateState(time: number)\r\n    {\r\n        this.state.update(time);\r\n        this.skeleton.update(time);\r\n\r\n        this._stateChanged = true;\r\n\r\n        this._boundsDirty = true;\r\n\r\n        this.onViewUpdate();\r\n    }\r\n\r\n    /**\r\n     * Applies the state to this spine instance.\r\n     * - updates the state to the skeleton\r\n     * - updates its world transform (spine world transform)\r\n     * - validates the attachments - to flag if the attachments have changed this state\r\n     * - transforms the attachments - to update the vertices of the attachments based on the new positions\r\n     * - update the slot attachments - to update the position, rotation, scale, and visibility of the attached containers\r\n     * @internal\r\n     */\r\n    _applyState()\r\n    {\r\n        if (!this._stateChanged) return;\r\n        this._stateChanged = false;\r\n\r\n        const { skeleton } = this;\r\n\r\n        this.state.apply(skeleton);\r\n\r\n        this.beforeUpdateWorldTransforms(this);\r\n        skeleton.updateWorldTransform(Physics.update);\r\n        this.afterUpdateWorldTransforms(this);\r\n\r\n        this.validateAttachments();\r\n\r\n        this.transformAttachments();\r\n\r\n        this.updateSlotObjects();\r\n    }\r\n\r\n    private validateAttachments()\r\n    {\r\n        const currentDrawOrder = this.skeleton.drawOrder;\r\n\r\n        const lastAttachments = (this._lastAttachments ||= []);\r\n\r\n        let index = 0;\r\n\r\n        let spineAttachmentsDirty = false;\r\n\r\n        for (let i = 0; i < currentDrawOrder.length; i++)\r\n        {\r\n            const slot = currentDrawOrder[i];\r\n            const attachment = slot.getAttachment();\r\n\r\n            if (attachment)\r\n            {\r\n                if (attachment !== lastAttachments[index])\r\n                {\r\n                    spineAttachmentsDirty = true;\r\n                    lastAttachments[index] = attachment;\r\n                }\r\n\r\n                index++;\r\n            }\r\n        }\r\n\r\n        if (index !== lastAttachments.length)\r\n        {\r\n            spineAttachmentsDirty = true;\r\n            lastAttachments.length = index;\r\n        }\r\n\r\n        this.spineAttachmentsDirty = spineAttachmentsDirty;\r\n    }\r\n\r\n    private transformAttachments()\r\n    {\r\n        const currentDrawOrder = this.skeleton.drawOrder;\r\n\r\n        for (let i = 0; i < currentDrawOrder.length; i++)\r\n        {\r\n            const slot = currentDrawOrder[i];\r\n\r\n            const attachment = slot.getAttachment();\r\n\r\n            if (attachment)\r\n            {\r\n                if (attachment instanceof MeshAttachment || attachment instanceof RegionAttachment)\r\n                {\r\n                    const cacheData = this._getCachedData(slot, attachment);\r\n\r\n                    if (attachment instanceof RegionAttachment)\r\n                    {\r\n                        attachment.computeWorldVertices(slot, cacheData.vertices, 0, 2);\r\n                    }\r\n                    else\r\n                    {\r\n                        attachment.computeWorldVertices(\r\n                            slot,\r\n                            0,\r\n                            attachment.worldVerticesLength,\r\n                            cacheData.vertices,\r\n                            0,\r\n                            2,\r\n                        );\r\n                    }\r\n\r\n                    cacheData.uvs = attachment.uvs as Float32Array;\r\n\r\n                    const skeleton = slot.bone.skeleton;\r\n                    const skeletonColor = skeleton.color;\r\n                    const slotColor = slot.color;\r\n\r\n                    const attachmentColor = attachment.color;\r\n\r\n                    cacheData.color.set(\r\n                        skeletonColor.r * slotColor.r * attachmentColor.r,\r\n                        skeletonColor.g * slotColor.g * attachmentColor.g,\r\n                        skeletonColor.b * slotColor.b * attachmentColor.b,\r\n                        skeletonColor.a * slotColor.a * attachmentColor.a,\r\n                    );\r\n\r\n                    cacheData.darkTint = !!slot.darkColor;\r\n\r\n                    if (slot.darkColor)\r\n                    {\r\n                        cacheData.darkColor.setFromColor(slot.darkColor);\r\n                    }\r\n\r\n                    cacheData.skipRender = cacheData.clipped = false;\r\n\r\n                    const texture = attachment.region?.texture.texture || Texture.EMPTY;\r\n\r\n                    if (cacheData.texture !== texture)\r\n                    {\r\n                        cacheData.texture = texture;\r\n                        this.spineTexturesDirty = true;\r\n                    }\r\n\r\n                    if (clipper.isClipping())\r\n                    {\r\n                        this.updateClippingData(cacheData);\r\n                    }\r\n                }\r\n                else if (attachment instanceof ClippingAttachment)\r\n                {\r\n                    clipper.clipStart(slot, attachment);\r\n                    continue;\r\n                }\r\n            }\r\n            clipper.clipEndWithSlot(slot);\r\n        }\r\n        clipper.clipEnd();\r\n    }\r\n\r\n    private updateClippingData(cacheData: AttachmentCacheData)\r\n    {\r\n        cacheData.clipped = true;\r\n\r\n        clipper.clipTriangles(\r\n            cacheData.vertices,\r\n            cacheData.vertices.length,\r\n            cacheData.indices,\r\n            cacheData.indices.length,\r\n            cacheData.uvs,\r\n            lightColor,\r\n            darkColor,\r\n            false,\r\n        );\r\n\r\n        const { clippedVertices, clippedTriangles } = clipper;\r\n\r\n        const verticesCount = clippedVertices.length / 8;\r\n        const indicesCount = clippedTriangles.length;\r\n\r\n        if (!cacheData.clippedData)\r\n        {\r\n            cacheData.clippedData = {\r\n                vertices: new Float32Array(verticesCount * 2),\r\n                uvs: new Float32Array(verticesCount * 2),\r\n                vertexCount: verticesCount,\r\n                indices: new Uint16Array(indicesCount),\r\n                indicesCount,\r\n            };\r\n\r\n            this.spineAttachmentsDirty = true;\r\n        }\r\n\r\n        const clippedData = cacheData.clippedData;\r\n\r\n        const sizeChange = clippedData.vertexCount !== verticesCount || indicesCount !== clippedData.indicesCount;\r\n\r\n        cacheData.skipRender = verticesCount === 0;\r\n\r\n        if (sizeChange)\r\n        {\r\n            this.spineAttachmentsDirty = true;\r\n\r\n            if (clippedData.vertexCount < verticesCount)\r\n            {\r\n                // buffer reuse!\r\n                clippedData.vertices = new Float32Array(verticesCount * 2);\r\n                clippedData.uvs = new Float32Array(verticesCount * 2);\r\n            }\r\n\r\n            if (clippedData.indices.length < indicesCount)\r\n            {\r\n                clippedData.indices = new Uint16Array(indicesCount);\r\n            }\r\n        }\r\n\r\n        const { vertices, uvs, indices } = clippedData;\r\n\r\n        for (let i = 0; i < verticesCount; i++)\r\n        {\r\n            vertices[i * 2] = clippedVertices[i * 8];\r\n            vertices[(i * 2) + 1] = clippedVertices[(i * 8) + 1];\r\n\r\n            uvs[i * 2] = clippedVertices[(i * 8) + 6];\r\n            uvs[(i * 2) + 1] = clippedVertices[(i * 8) + 7];\r\n        }\r\n\r\n        clippedData.vertexCount = verticesCount;\r\n\r\n        for (let i = 0; i < indices.length; i++)\r\n        {\r\n            indices[i] = clippedTriangles[i];\r\n        }\r\n\r\n        clippedData.indicesCount = indicesCount;\r\n    }\r\n\r\n    /**\r\n     * ensure that attached containers map correctly to their slots\r\n     * along with their position, rotation, scale, and visibility.\r\n     */\r\n    private updateSlotObjects()\r\n    {\r\n        for (const i in this._slotsObject)\r\n        {\r\n            const slotAttachment = this._slotsObject[i];\r\n\r\n            if (!slotAttachment) continue;\r\n\r\n            this.updateSlotObject(slotAttachment);\r\n        }\r\n    }\r\n\r\n    private updateSlotObject(slotAttachment: {slot:Slot, container:Container})\r\n    {\r\n        const { slot, container } = slotAttachment;\r\n\r\n        container.visible = this.skeleton.drawOrder.includes(slot);\r\n\r\n        if (container.visible)\r\n        {\r\n            const bone = slot.bone;\r\n\r\n            container.position.set(bone.worldX, bone.worldY);\r\n\r\n            container.scale.x = bone.getWorldScaleX();\r\n            container.scale.y = bone.getWorldScaleY();\r\n\r\n            container.rotation = bone.getWorldRotationX() * DEG_TO_RAD;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    _getCachedData(slot: Slot, attachment: RegionAttachment | MeshAttachment): AttachmentCacheData\r\n    {\r\n        return this.attachmentCacheData[slot.data.index][attachment.name] || this.initCachedData(slot, attachment);\r\n    }\r\n\r\n    private initCachedData(slot: Slot, attachment: RegionAttachment | MeshAttachment): AttachmentCacheData\r\n    {\r\n        let vertices: Float32Array;\r\n\r\n        if (attachment instanceof RegionAttachment)\r\n        {\r\n            vertices = new Float32Array(8);\r\n\r\n            this.attachmentCacheData[slot.data.index][attachment.name] = {\r\n                id: `${slot.data.index}-${attachment.name}`,\r\n                vertices,\r\n                clipped: false,\r\n                indices: [0, 1, 2, 0, 2, 3],\r\n                uvs: attachment.uvs as Float32Array,\r\n                color: new Color(1, 1, 1, 1),\r\n                darkColor: new Color(0, 0, 0, 0),\r\n                darkTint: false,\r\n                skipRender: false,\r\n                texture: attachment.region?.texture.texture,\r\n            };\r\n        }\r\n        else\r\n        {\r\n            vertices = new Float32Array(attachment.worldVerticesLength);\r\n\r\n            this.attachmentCacheData[slot.data.index][attachment.name] = {\r\n                id: `${slot.data.index}-${attachment.name}`,\r\n                vertices,\r\n                clipped: false,\r\n                indices: attachment.triangles,\r\n                uvs: attachment.uvs as Float32Array,\r\n                color: new Color(1, 1, 1, 1),\r\n                darkColor: new Color(0, 0, 0, 0),\r\n                darkTint: false,\r\n                skipRender: false,\r\n                texture: attachment.region?.texture.texture,\r\n            };\r\n        }\r\n\r\n        return this.attachmentCacheData[slot.data.index][attachment.name];\r\n    }\r\n\r\n    protected onViewUpdate()\r\n    {\r\n        // increment from the 12th bit!\r\n        this._didChangeId += 1 << 12;\r\n\r\n        this._boundsDirty = true;\r\n\r\n        if (this.didViewUpdate) return;\r\n        this.didViewUpdate = true;\r\n\r\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\r\n\r\n        if (renderGroup)\r\n        {\r\n            renderGroup.onChildViewUpdate(this);\r\n        }\r\n\r\n        this.debug?.renderDebug(this);\r\n    }\r\n\r\n    /**\r\n     * Attaches a PixiJS container to a specified slot. This will map the world transform of the slots bone\r\n     * to the attached container. A container can only be attached to one slot at a time.\r\n     *\r\n     * @param container - The container to attach to the slot\r\n     * @param slotRef - The slot id or  slot to attach to\r\n     */\r\n    public addSlotObject(slot: number | string | Slot, container: Container)\r\n    {\r\n        slot = this.getSlotFromRef(slot);\r\n\r\n        // need to check in on the container too...\r\n        for (const i in this._slotsObject)\r\n        {\r\n            if (this._slotsObject[i]?.container === container)\r\n            {\r\n                this.removeSlotObject(this._slotsObject[i].slot);\r\n            }\r\n        }\r\n\r\n        this.removeSlotObject(slot);\r\n\r\n        container.includeInBuild = false;\r\n\r\n        // TODO only add once??\r\n        this.addChild(container);\r\n\r\n        this._slotsObject[slot.data.name] = {\r\n            container,\r\n            slot\r\n        };\r\n\r\n        this.updateSlotObject(this._slotsObject[slot.data.name]);\r\n    }\r\n\r\n    /**\r\n     * Removes a PixiJS container from the slot it is attached to.\r\n     *\r\n     * @param container - The container to detach from the slot\r\n     * @param slotOrContainer - The container, slot id or slot to detach from\r\n     */\r\n    public removeSlotObject(slotOrContainer: number | string | Slot | Container)\r\n    {\r\n        let containerToRemove: Container | undefined;\r\n\r\n        if (slotOrContainer instanceof Container)\r\n        {\r\n            for (const i in this._slotsObject)\r\n            {\r\n                if (this._slotsObject[i]?.container === slotOrContainer)\r\n                {\r\n                    this._slotsObject[i] = null;\r\n\r\n                    containerToRemove = slotOrContainer;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            const slot = this.getSlotFromRef(slotOrContainer);\r\n\r\n            containerToRemove = this._slotsObject[slot.data.name]?.container;\r\n            this._slotsObject[slot.data.name] = null;\r\n        }\r\n\r\n        if (containerToRemove)\r\n        {\r\n            this.removeChild(containerToRemove);\r\n\r\n            containerToRemove.includeInBuild = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a container attached to a slot, or undefined if no container is attached.\r\n     *\r\n     * @param slotRef - The slot id or slot to get the attachment from\r\n     * @returns - The container attached to the slot\r\n     */\r\n    public getSlotObject(slot: number | string | Slot)\r\n    {\r\n        slot = this.getSlotFromRef(slot);\r\n\r\n        return this._slotsObject[slot.data.name].container;\r\n    }\r\n\r\n    private updateBounds()\r\n    {\r\n        this._boundsDirty = false;\r\n\r\n        this.skeletonBounds ||= new SkeletonBounds();\r\n\r\n        const skeletonBounds = this.skeletonBounds;\r\n\r\n        skeletonBounds.update(this.skeleton, true);\r\n\r\n        if (skeletonBounds.minX === Infinity)\r\n        {\r\n            this._applyState();\r\n\r\n            const drawOrder = this.skeleton.drawOrder;\r\n            const bounds = this._bounds;\r\n\r\n            bounds.clear();\r\n\r\n            for (let i = 0; i < drawOrder.length; i++)\r\n            {\r\n                const slot = drawOrder[i];\r\n\r\n                const attachment = slot.getAttachment();\r\n\r\n                if (attachment && (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment))\r\n                {\r\n                    const cacheData = this._getCachedData(slot, attachment);\r\n\r\n                    bounds.addVertexData(cacheData.vertices, 0, cacheData.vertices.length);\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this._bounds.minX = skeletonBounds.minX;\r\n            this._bounds.minY = skeletonBounds.minY;\r\n            this._bounds.maxX = skeletonBounds.maxX;\r\n            this._bounds.maxY = skeletonBounds.maxY;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    addBounds(bounds: Bounds)\r\n    {\r\n        bounds.addBounds(this.bounds);\r\n    }\r\n\r\n    /**\r\n     * Destroys this sprite renderable and optionally its texture.\r\n     * @param options - Options parameter. A boolean will act as if all options\r\n     *  have been set to that value\r\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\r\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\r\n     */\r\n    public override destroy(options: DestroyOptions = false)\r\n    {\r\n        super.destroy(options);\r\n\r\n        Ticker.shared.remove(this.internalUpdate, this);\r\n        this.state.clearListeners();\r\n        this.debug = undefined;\r\n        this.skeleton = null as any;\r\n        this.state = null as any;\r\n        (this._slotsObject as any) = null;\r\n        this._lastAttachments = null;\r\n        this.attachmentCacheData = null as any;\r\n    }\r\n\r\n    /** Converts a point from the skeleton coordinate system to the Pixi world coordinate system. */\r\n    public skeletonToPixiWorldCoordinates(point: { x: number; y: number })\r\n    {\r\n        this.worldTransform.apply(point, point);\r\n    }\r\n\r\n    /** Converts a point from the Pixi world coordinate system to the skeleton coordinate system. */\r\n    public pixiWorldCoordinatesToSkeleton(point: { x: number; y: number })\r\n    {\r\n        this.worldTransform.applyInverse(point, point);\r\n    }\r\n\r\n    /** Converts a point from the Pixi world coordinate system to the bone's local coordinate system. */\r\n    public pixiWorldCoordinatesToBone(point: { x: number; y: number }, bone: Bone)\r\n    {\r\n        this.pixiWorldCoordinatesToSkeleton(point);\r\n        if (bone.parent)\r\n        {\r\n            bone.parent.worldToLocal(point as Vector2);\r\n        }\r\n        else\r\n        {\r\n            bone.worldToLocal(point as Vector2);\r\n        }\r\n    }\r\n\r\n    static from({ skeleton, atlas, scale = 1 }: SpineFromOptions)\r\n    {\r\n        const cacheKey = `${skeleton}-${atlas}-${scale}`;\r\n\r\n        if (Cache.has(cacheKey))\r\n        {\r\n            return new Spine(Cache.get<SkeletonData>(cacheKey));\r\n        }\r\n\r\n        const skeletonAsset = Assets.get<any | Uint8Array>(skeleton);\r\n\r\n        const atlasAsset = Assets.get<TextureAtlas>(atlas);\r\n        const attachmentLoader = new AtlasAttachmentLoader(atlasAsset);\r\n        // eslint-disable-next-line max-len\r\n        const parser\r\n            = skeletonAsset instanceof Uint8Array\r\n                ? new SkeletonBinary(attachmentLoader)\r\n                : new SkeletonJson(attachmentLoader);\r\n\r\n        // TODO scale?\r\n        parser.scale = scale;\r\n        const skeletonData = parser.readSkeletonData(skeletonAsset);\r\n\r\n        Cache.set(cacheKey, skeletonData);\r\n\r\n        return new Spine({\r\n            skeletonData,\r\n        });\r\n    }\r\n}\r\n","/** ****************************************************************************\r\n * Spine Runtimes License Agreement\r\n * Last updated July 28, 2023. Replaces all prior versions.\r\n *\r\n * Copyright (c) 2013-2023, Esoteric Software LLC\r\n *\r\n * Integration of the Spine Runtimes into software or otherwise creating\r\n * derivative works of the Spine Runtimes is permitted under the terms and\r\n * conditions of Section 2 of the Spine Editor License Agreement:\r\n * http://esotericsoftware.com/spine-editor-license\r\n *\r\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\r\n * otherwise create derivative works of the Spine Runtimes (collectively,\r\n * \"Products\"), provided that each user of the Products must obtain their own\r\n * Spine Editor license and redistribution of the Products in any form must\r\n * include this license and copyright notice.\r\n *\r\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\r\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\r\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\r\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nimport { Container, Graphics, Text } from 'pixi.js';\r\nimport { Spine } from './Spine';\r\nimport {\r\n    ClippingAttachment,\r\n    MeshAttachment,\r\n    PathAttachment,\r\n    RegionAttachment,\r\n    SkeletonBounds\r\n} from '@esotericsoftware/spine-core';\r\n\r\nimport type { AnimationStateListener } from '@esotericsoftware/spine-core';\r\n\r\n/**\r\n * Make a class that extends from this interface to create your own debug renderer.\r\n * @public\r\n */\r\nexport interface ISpineDebugRenderer\r\n{\r\n    /**\r\n     * This will be called every frame, after the spine has been updated.\r\n     */\r\n    renderDebug: (spine: Spine) => void;\r\n\r\n    /**\r\n     *  This is called when the `spine.debug` object is set to null or when the spine is destroyed.\r\n     */\r\n    unregisterSpine: (spine: Spine) => void;\r\n\r\n    /**\r\n     * This is called when the `spine.debug` object is set to a new instance of a debug renderer.\r\n     */\r\n    registerSpine: (spine: Spine) => void;\r\n}\r\n\r\ntype DebugDisplayObjects = {\r\n    bones: Container;\r\n    skeletonXY: Graphics;\r\n    regionAttachmentsShape: Graphics;\r\n    meshTrianglesLine: Graphics;\r\n    meshHullLine: Graphics;\r\n    clippingPolygon: Graphics;\r\n    boundingBoxesRect: Graphics;\r\n    boundingBoxesCircle: Graphics;\r\n    boundingBoxesPolygon: Graphics;\r\n    pathsCurve: Graphics;\r\n    pathsLine: Graphics;\r\n    parentDebugContainer: Container;\r\n    eventText: Container;\r\n    eventCallback: AnimationStateListener;\r\n};\r\n\r\n/**\r\n * This is a debug renderer that uses PixiJS Graphics under the hood.\r\n * @public\r\n */\r\nexport class SpineDebugRenderer implements ISpineDebugRenderer\r\n{\r\n    private readonly registeredSpines: Map<Spine, DebugDisplayObjects> = new Map();\r\n\r\n    public drawMeshHull = true;\r\n    public drawMeshTriangles = true;\r\n    public drawBones = true;\r\n    public drawPaths = true;\r\n    public drawBoundingBoxes = true;\r\n    public drawClipping = true;\r\n    public drawRegionAttachments = true;\r\n    public drawEvents = true;\r\n\r\n    public lineWidth = 1;\r\n    public regionAttachmentsColor = 0x0078ff;\r\n    public meshHullColor = 0x0078ff;\r\n    public meshTrianglesColor = 0xffcc00;\r\n    public clippingPolygonColor = 0xff00ff;\r\n    public boundingBoxesRectColor = 0x00ff00;\r\n    public boundingBoxesPolygonColor = 0x00ff00;\r\n    public boundingBoxesCircleColor = 0x00ff00;\r\n    public pathsCurveColor = 0xff0000;\r\n    public pathsLineColor = 0xff00ff;\r\n    public skeletonXYColor = 0xff0000;\r\n    public bonesColor = 0x00eecc;\r\n    public eventFontSize = 24;\r\n    public eventFontColor = 0x0;\r\n\r\n    /**\r\n     * The debug is attached by force to each spine object.\r\n     * So we need to create it inside the spine when we get the first update\r\n     */\r\n    public registerSpine(spine: Spine): void\r\n    {\r\n        if (this.registeredSpines.has(spine))\r\n        {\r\n            console.warn('SpineDebugRenderer.registerSpine() - this spine is already registered!', spine);\r\n\r\n            return;\r\n        }\r\n        const debugDisplayObjects: DebugDisplayObjects = {\r\n            parentDebugContainer: new Container(),\r\n            bones: new Container(),\r\n            skeletonXY: new Graphics(),\r\n            regionAttachmentsShape: new Graphics(),\r\n            meshTrianglesLine: new Graphics(),\r\n            meshHullLine: new Graphics(),\r\n            clippingPolygon: new Graphics(),\r\n            boundingBoxesRect: new Graphics(),\r\n            boundingBoxesCircle: new Graphics(),\r\n            boundingBoxesPolygon: new Graphics(),\r\n            pathsCurve: new Graphics(),\r\n            pathsLine: new Graphics(),\r\n            eventText: new Container(),\r\n            eventCallback: {\r\n                event: (_, event) =>\r\n                {\r\n                    if (this.drawEvents)\r\n                    {\r\n                        const scale = Math.abs(spine.scale.x || spine.scale.y || 1);\r\n                        const text = new Text({\r\n                            text: event.data.name,\r\n                            style: {\r\n                                fontSize: this.eventFontSize / scale,\r\n                                fill: this.eventFontColor,\r\n                                fontFamily: 'monospace'\r\n                            }\r\n                        });\r\n\r\n                        text.scale.x = Math.sign(spine.scale.x);\r\n                        text.anchor.set(0.5);\r\n                        debugDisplayObjects.eventText.addChild(text);\r\n                        setTimeout(() =>\r\n                        {\r\n                            if (!text.destroyed)\r\n                            {\r\n                                text.destroy();\r\n                            }\r\n                        }, 250);\r\n                    }\r\n                },\r\n            },\r\n        };\r\n\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.bones);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.skeletonXY);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.regionAttachmentsShape);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshTrianglesLine);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshHullLine);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.clippingPolygon);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesRect);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesCircle);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesPolygon);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsCurve);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsLine);\r\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.eventText);\r\n\r\n        (debugDisplayObjects.parentDebugContainer as any).zIndex = 9999999;\r\n\r\n        // Disable screen reader and mouse input on debug objects.\r\n        (debugDisplayObjects.parentDebugContainer as any).accessibleChildren = false;\r\n        (debugDisplayObjects.parentDebugContainer as any).eventMode = 'none';\r\n        (debugDisplayObjects.parentDebugContainer as any).interactiveChildren = false;\r\n\r\n        spine.addChild(debugDisplayObjects.parentDebugContainer);\r\n\r\n        spine.state.addListener(debugDisplayObjects.eventCallback);\r\n\r\n        this.registeredSpines.set(spine, debugDisplayObjects);\r\n    }\r\n\r\n    public renderDebug(spine: Spine): void\r\n    {\r\n        if (!this.registeredSpines.has(spine))\r\n        {\r\n            // This should never happen. Spines are registered when you assign spine.debug\r\n            this.registerSpine(spine);\r\n        }\r\n\r\n        const debugDisplayObjects = this.registeredSpines.get(spine);\r\n\r\n        if (!debugDisplayObjects)\r\n        {\r\n            return;\r\n        }\r\n        spine.addChild(debugDisplayObjects.parentDebugContainer);\r\n\r\n        debugDisplayObjects.skeletonXY.clear();\r\n        debugDisplayObjects.regionAttachmentsShape.clear();\r\n        debugDisplayObjects.meshTrianglesLine.clear();\r\n        debugDisplayObjects.meshHullLine.clear();\r\n        debugDisplayObjects.clippingPolygon.clear();\r\n        debugDisplayObjects.boundingBoxesRect.clear();\r\n        debugDisplayObjects.boundingBoxesCircle.clear();\r\n        debugDisplayObjects.boundingBoxesPolygon.clear();\r\n        debugDisplayObjects.pathsCurve.clear();\r\n        debugDisplayObjects.pathsLine.clear();\r\n\r\n        for (let len = debugDisplayObjects.bones.children.length; len > 0; len--)\r\n        {\r\n            debugDisplayObjects.bones.children[len - 1].destroy({ children: true, texture: true, textureSource: true });\r\n        }\r\n\r\n        const scale = Math.abs(spine.scale.x || spine.scale.y || 1);\r\n        const lineWidth = this.lineWidth / scale;\r\n\r\n        if (this.drawBones)\r\n        {\r\n            this.drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale);\r\n        }\r\n\r\n        if (this.drawPaths)\r\n        {\r\n            this.drawPathsFunc(spine, debugDisplayObjects, lineWidth);\r\n        }\r\n\r\n        if (this.drawBoundingBoxes)\r\n        {\r\n            this.drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth);\r\n        }\r\n\r\n        if (this.drawClipping)\r\n        {\r\n            this.drawClippingFunc(spine, debugDisplayObjects, lineWidth);\r\n        }\r\n\r\n        if (this.drawMeshHull || this.drawMeshTriangles)\r\n        {\r\n            this.drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth);\r\n        }\r\n\r\n        if (this.drawRegionAttachments)\r\n        {\r\n            this.drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth);\r\n        }\r\n\r\n        if (this.drawEvents)\r\n        {\r\n            for (const child of debugDisplayObjects.eventText.children)\r\n            {\r\n                child.alpha -= 0.05;\r\n                child.y -= 2;\r\n            }\r\n        }\r\n    }\r\n\r\n    private drawBonesFunc(spine: Spine, debugDisplayObjects: DebugDisplayObjects, lineWidth: number, scale: number): void\r\n    {\r\n        const skeleton = spine.skeleton;\r\n        const skeletonX = skeleton.x;\r\n        const skeletonY = skeleton.y;\r\n        const bones = skeleton.bones;\r\n\r\n        debugDisplayObjects.skeletonXY.strokeStyle = { width: lineWidth, color: this.skeletonXYColor };\r\n\r\n        for (let i = 0, len = bones.length; i < len; i++)\r\n        {\r\n            const bone = bones[i];\r\n            const boneLen = bone.data.length;\r\n            const starX = skeletonX + bone.worldX;\r\n            const starY = skeletonY + bone.worldY;\r\n            const endX = skeletonX + (boneLen * bone.a) + bone.worldX;\r\n            const endY = skeletonY + (boneLen * bone.b) + bone.worldY;\r\n\r\n            if (bone.data.name === 'root' || bone.data.parent === null)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            const w = Math.abs(starX - endX);\r\n            const h = Math.abs(starY - endY);\r\n            // a = w, // side length a\r\n            const a2 = Math.pow(w, 2); // square root of side length a\r\n            const b = h; // side length b\r\n            const b2 = Math.pow(h, 2); // square root of side length b\r\n            const c = Math.sqrt(a2 + b2); // side length c\r\n            const c2 = Math.pow(c, 2); // square root of side length c\r\n            const rad = Math.PI / 180;\r\n            // A = Math.acos([a2 + c2 - b2] / [2 * a * c]) || 0, // Angle A\r\n            // C = Math.acos([a2 + b2 - c2] / [2 * a * b]) || 0, // C angle\r\n            const B = Math.acos((c2 + b2 - a2) / (2 * b * c)) || 0; // angle of corner B\r\n\r\n            if (c === 0)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            const gp = new Graphics();\r\n\r\n            debugDisplayObjects.bones.addChild(gp);\r\n\r\n            // draw bone\r\n            const refRation = c / 50 / scale;\r\n\r\n            gp.context\r\n                .poly([0, 0, 0 - refRation, c - (refRation * 3), 0, c - refRation, 0 + refRation, c - (refRation * 3)])\r\n                .fill(this.bonesColor);\r\n            gp.x = starX;\r\n            gp.y = starY;\r\n            gp.pivot.y = c;\r\n\r\n            // Calculate bone rotation angle\r\n            let rotation = 0;\r\n\r\n            if (starX < endX && starY < endY)\r\n            {\r\n                // bottom right\r\n                rotation = -B + (180 * rad);\r\n            }\r\n            else if (starX > endX && starY < endY)\r\n            {\r\n                // bottom left\r\n                rotation = 180 * (rad + B);\r\n            }\r\n            else if (starX > endX && starY > endY)\r\n            {\r\n                // top left\r\n                rotation = -B;\r\n            }\r\n            else if (starX < endX && starY > endY)\r\n            {\r\n                // bottom left\r\n                rotation = B;\r\n            }\r\n            else if (starY === endY && starX < endX)\r\n            {\r\n                // To the right\r\n                rotation = 90 * rad;\r\n            }\r\n            else if (starY === endY && starX > endX)\r\n            {\r\n                // go left\r\n                rotation = -90 * rad;\r\n            }\r\n            else if (starX === endX && starY < endY)\r\n            {\r\n                // down\r\n                rotation = 180 * rad;\r\n            }\r\n            else if (starX === endX && starY > endY)\r\n            {\r\n                // up\r\n                rotation = 0;\r\n            }\r\n            gp.rotation = rotation;\r\n\r\n            // Draw the starting rotation point of the bone\r\n            gp.circle(0, c, refRation * 1.2)\r\n                .fill({ color: 0x000000, alpha: 0.6 })\r\n                .stroke({ width: lineWidth, color: this.skeletonXYColor });\r\n        }\r\n\r\n        // Draw the skeleton starting point \"X\" form\r\n        const startDotSize = lineWidth * 3;\r\n\r\n        debugDisplayObjects.skeletonXY.context\r\n            .moveTo(skeletonX - startDotSize, skeletonY - startDotSize)\r\n            .lineTo(skeletonX + startDotSize, skeletonY + startDotSize)\r\n            .moveTo(skeletonX + startDotSize, skeletonY - startDotSize)\r\n            .lineTo(skeletonX - startDotSize, skeletonY + startDotSize)\r\n            .stroke();\r\n    }\r\n\r\n    private drawRegionAttachmentsFunc(spine: Spine, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void\r\n    {\r\n        const skeleton = spine.skeleton;\r\n        const slots = skeleton.slots;\r\n\r\n        for (let i = 0, len = slots.length; i < len; i++)\r\n        {\r\n            const slot = slots[i];\r\n            const attachment = slot.getAttachment();\r\n\r\n            if (attachment === null || !(attachment instanceof RegionAttachment))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            const regionAttachment = attachment;\r\n\r\n            const vertices = new Float32Array(8);\r\n\r\n            regionAttachment.computeWorldVertices(slot, vertices, 0, 2);\r\n\r\n            debugDisplayObjects.regionAttachmentsShape.poly(Array.from(vertices.slice(0, 8)));\r\n        }\r\n\r\n        debugDisplayObjects.regionAttachmentsShape.stroke({\r\n            color: this.regionAttachmentsColor,\r\n            width: lineWidth\r\n        });\r\n    }\r\n\r\n    private drawMeshHullAndMeshTriangles(spine: Spine, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void\r\n    {\r\n        const skeleton = spine.skeleton;\r\n        const slots = skeleton.slots;\r\n\r\n        for (let i = 0, len = slots.length; i < len; i++)\r\n        {\r\n            const slot = slots[i];\r\n\r\n            if (!slot.bone.active)\r\n            {\r\n                continue;\r\n            }\r\n            const attachment = slot.getAttachment();\r\n\r\n            if (attachment === null || !(attachment instanceof MeshAttachment))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            const meshAttachment = attachment;\r\n\r\n            const vertices = new Float32Array(meshAttachment.worldVerticesLength);\r\n            const triangles = meshAttachment.triangles;\r\n            let hullLength = meshAttachment.hullLength;\r\n\r\n            meshAttachment.computeWorldVertices(slot, 0, meshAttachment.worldVerticesLength, vertices, 0, 2);\r\n            // draw the skinned mesh (triangle)\r\n            if (this.drawMeshTriangles)\r\n            {\r\n                for (let i = 0, len = triangles.length; i < len; i += 3)\r\n                {\r\n                    const v1 = triangles[i] * 2;\r\n                    const v2 = triangles[i + 1] * 2;\r\n                    const v3 = triangles[i + 2] * 2;\r\n\r\n                    debugDisplayObjects.meshTrianglesLine.context\r\n                        .moveTo(vertices[v1], vertices[v1 + 1])\r\n                        .lineTo(vertices[v2], vertices[v2 + 1])\r\n                        .lineTo(vertices[v3], vertices[v3 + 1]);\r\n                }\r\n            }\r\n\r\n            // draw skin border\r\n            if (this.drawMeshHull && hullLength > 0)\r\n            {\r\n                hullLength = (hullLength >> 1) * 2;\r\n                let lastX = vertices[hullLength - 2];\r\n                let lastY = vertices[hullLength - 1];\r\n\r\n                for (let i = 0, len = hullLength; i < len; i += 2)\r\n                {\r\n                    const x = vertices[i];\r\n                    const y = vertices[i + 1];\r\n\r\n                    debugDisplayObjects.meshHullLine.context\r\n                        .moveTo(x, y)\r\n                        .lineTo(lastX, lastY);\r\n                    lastX = x;\r\n                    lastY = y;\r\n                }\r\n            }\r\n        }\r\n\r\n        debugDisplayObjects.meshHullLine.stroke({ width: lineWidth, color: this.meshHullColor });\r\n        debugDisplayObjects.meshTrianglesLine.stroke({ width: lineWidth, color: this.meshTrianglesColor });\r\n    }\r\n\r\n    drawClippingFunc(spine: Spine, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void\r\n    {\r\n        const skeleton = spine.skeleton;\r\n        const slots = skeleton.slots;\r\n\r\n        for (let i = 0, len = slots.length; i < len; i++)\r\n        {\r\n            const slot = slots[i];\r\n\r\n            if (!slot.bone.active)\r\n            {\r\n                continue;\r\n            }\r\n            const attachment = slot.getAttachment();\r\n\r\n            if (attachment === null || !(attachment instanceof ClippingAttachment))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            const clippingAttachment = attachment;\r\n\r\n            const nn = clippingAttachment.worldVerticesLength;\r\n            const world = new Float32Array(nn);\r\n\r\n            clippingAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\r\n            debugDisplayObjects.clippingPolygon.poly(Array.from(world));\r\n        }\r\n\r\n        debugDisplayObjects.clippingPolygon.stroke({\r\n            width: lineWidth, color: this.clippingPolygonColor, alpha: 1\r\n        });\r\n    }\r\n\r\n    drawBoundingBoxesFunc(spine: Spine, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void\r\n    {\r\n        // draw the total outline of the bounding box\r\n        debugDisplayObjects.boundingBoxesRect.lineStyle(lineWidth, this.boundingBoxesRectColor, 5);\r\n\r\n        const bounds = new SkeletonBounds();\r\n\r\n        bounds.update(spine.skeleton, true);\r\n\r\n        debugDisplayObjects.boundingBoxesRect\r\n            .rect(bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight())\r\n            .stroke({ width: lineWidth, color: this.boundingBoxesRectColor });\r\n\r\n        const polygons = bounds.polygons;\r\n        const drawPolygon = (polygonVertices: ArrayLike<number>, _offset: unknown, count: number): void =>\r\n        {\r\n            if (count < 3)\r\n            {\r\n                throw new Error('Polygon must contain at least 3 vertices');\r\n            }\r\n            const paths:number[] = [];\r\n            const dotSize = lineWidth * 2;\r\n\r\n            for (let i = 0, len = polygonVertices.length; i < len; i += 2)\r\n            {\r\n                const x1 = polygonVertices[i];\r\n                const y1 = polygonVertices[i + 1];\r\n\r\n                // draw the bounding box node\r\n                debugDisplayObjects.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor);\r\n                debugDisplayObjects.boundingBoxesCircle.drawCircle(x1, y1, dotSize);\r\n                debugDisplayObjects.boundingBoxesCircle.fill(0);\r\n\r\n                paths.push(x1, y1);\r\n            }\r\n\r\n            // draw the bounding box area\r\n            debugDisplayObjects.boundingBoxesPolygon\r\n                .poly(paths)\r\n                .fill({\r\n                    color: this.boundingBoxesPolygonColor,\r\n                    alpha: 0.1\r\n                })\r\n                .stroke({\r\n                    width: lineWidth,\r\n                    color: this.boundingBoxesPolygonColor\r\n                });\r\n        };\r\n\r\n        for (let i = 0, len = polygons.length; i < len; i++)\r\n        {\r\n            const polygon = polygons[i];\r\n\r\n            drawPolygon(polygon, 0, polygon.length);\r\n        }\r\n    }\r\n\r\n    private drawPathsFunc(spine: Spine, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void\r\n    {\r\n        const skeleton = spine.skeleton;\r\n        const slots = skeleton.slots;\r\n\r\n        for (let i = 0, len = slots.length; i < len; i++)\r\n        {\r\n            const slot = slots[i];\r\n\r\n            if (!slot.bone.active)\r\n            {\r\n                continue;\r\n            }\r\n            const attachment = slot.getAttachment();\r\n\r\n            if (attachment === null || !(attachment instanceof PathAttachment))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            const pathAttachment = attachment;\r\n            let nn = pathAttachment.worldVerticesLength;\r\n            const world = new Float32Array(nn);\r\n\r\n            pathAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\r\n            let x1 = world[2];\r\n            let y1 = world[3];\r\n            let x2 = 0;\r\n            let y2 = 0;\r\n\r\n            if (pathAttachment.closed)\r\n            {\r\n                const cx1 = world[0];\r\n                const cy1 = world[1];\r\n                const cx2 = world[nn - 2];\r\n                const cy2 = world[nn - 1];\r\n\r\n                x2 = world[nn - 4];\r\n                y2 = world[nn - 3];\r\n\r\n                // curve\r\n                debugDisplayObjects.pathsCurve.moveTo(x1, y1);\r\n                debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\r\n\r\n                // handle\r\n                debugDisplayObjects.pathsLine.moveTo(x1, y1);\r\n                debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\r\n                debugDisplayObjects.pathsLine.moveTo(x2, y2);\r\n                debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\r\n            }\r\n            nn -= 4;\r\n            for (let ii = 4; ii < nn; ii += 6)\r\n            {\r\n                const cx1 = world[ii];\r\n                const cy1 = world[ii + 1];\r\n                const cx2 = world[ii + 2];\r\n                const cy2 = world[ii + 3];\r\n\r\n                x2 = world[ii + 4];\r\n                y2 = world[ii + 5];\r\n                // curve\r\n                debugDisplayObjects.pathsCurve.moveTo(x1, y1);\r\n                debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\r\n\r\n                // handle\r\n                debugDisplayObjects.pathsLine.moveTo(x1, y1);\r\n                debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\r\n                debugDisplayObjects.pathsLine.moveTo(x2, y2);\r\n                debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\r\n                x1 = x2;\r\n                y1 = y2;\r\n            }\r\n        }\r\n\r\n        debugDisplayObjects.pathsCurve.stroke({ width: lineWidth, color: this.pathsCurveColor });\r\n        debugDisplayObjects.pathsLine.stroke({ width: lineWidth, color: this.pathsLineColor });\r\n    }\r\n\r\n    public unregisterSpine(spine: Spine): void\r\n    {\r\n        if (!this.registeredSpines.has(spine))\r\n        {\r\n            console.warn('SpineDebugRenderer.unregisterSpine() - spine is not registered, can\\'t unregister!', spine);\r\n        }\r\n        const debugDisplayObjects = this.registeredSpines.get(spine);\r\n\r\n        if (!debugDisplayObjects)\r\n        {\r\n            return;\r\n        }\r\n\r\n        spine.state.removeListener(debugDisplayObjects.eventCallback);\r\n\r\n        debugDisplayObjects.parentDebugContainer.destroy({ textureSource: true, children: true, texture: true });\r\n        this.registeredSpines.delete(spine);\r\n    }\r\n}\r\n"],"names":["prevRequire","x","c","a","i","e","o","_SpineTexture","Texture","image","__publicField","PixiTexture","texture","minFilter","magFilter","style","uWrap","vWrap","filter","TextureFilter","wrap","TextureWrap","blend","BlendMode","SpineTexture","R","w","S","u","L","M","t","s","d","spineTextureAtlasLoader","ExtensionType","LoaderParserPriority","url","checkExtension","DOMAdapter","asset","options","isExtensionRight","isString","atlas","loader","metadata","basePath","path","retval","TextureAtlas","TextureSource","pixiTexture","textureLoadingPromises","page","pageName","providedPage","assetsToLoadIn","__spreadProps","__spreadValues","pixiPromise","extensions","isJson","resource","isBuffer","spineLoaderExtension","response","isJsonSpineModel","isBinarySpineModel","placeHolderBufferData","placeHolderIndexData","DarkTintBatchGeometry","Geometry","attributeBuffer","Buffer","BufferUsage","indexBuffer","stride","darkTintBit","darkTintBitGl","DarkTintShader","Shader","maxTextures","glProgram","compileHighShaderGlProgram","colorBitGl","generateTextureBatchBitGl","roundPixelsBitGl","gpuProgram","compileHighShaderGpuProgram","colorBit","generateTextureBatchBit","roundPixelsBit","getBatchSamplersUniformGroup","defaultShader","_DarkTintBatcher","Batcher","element","float32View","uint32View","index","textureId","textureIdAndRound","wt","b","tx","ty","positions","uvs","argb","worldAlpha","darkColor","Color","offset","end","i2","y","bounds","w0","w1","h0","h1","DarkTintBatcher","BatchableSpineSlot","slotColor","parentColor","parentAlpha","abgr","mixedA","parentB","parentG","parentR","mixedR","mixedG","mixedB","renderable","data","blendMode","roundPixels","clippedData","clipper","SkeletonClipping","spineBlendModeMap","SpinePipe","renderer","spine","_a","drawOrder","gpuSpine","n","slot","attachment","RegionAttachment","MeshAttachment","cacheData","batchableSpineSlot","instructionSet","_b","_c","_d","batcher","containerAttachment","container","collectAllRenderables","vectorAux","Vector2","lightColor","Skeleton","Spine","ViewContainer","SkeletonData","skeletonData","AnimationState","AnimationStateData","slots","slotRef","value","Ticker","dt","_deltaFrame","deltaSeconds","bone","position","boneAux","aux","outPos","time","skeleton","Physics","currentDrawOrder","lastAttachments","spineAttachmentsDirty","skeletonColor","attachmentColor","ClippingAttachment","clippedVertices","clippedTriangles","verticesCount","indicesCount","sizeChange","vertices","indices","slotAttachment","DEG_TO_RAD","renderGroup","slotOrContainer","containerToRemove","Container","SkeletonBounds","skeletonBounds","point","scale","cacheKey","Cache","skeletonAsset","Assets","atlasAsset","attachmentLoader","AtlasAttachmentLoader","parser","SkeletonBinary","SkeletonJson","SpineDebugRenderer","debugDisplayObjects","Graphics","_","event","text","Text","len","lineWidth","child","skeletonX","skeletonY","bones","boneLen","starX","starY","endX","endY","h","a2","b2","c2","rad","B","gp","refRation","rotation","startDotSize","regionAttachment","meshAttachment","triangles","hullLength","v1","v2","v3","lastX","lastY","clippingAttachment","nn","world","polygons","drawPolygon","polygonVertices","_offset","count","paths","dotSize","x1","y1","polygon","PathAttachment","pathAttachment","x2","y2","cx1","cy1","cx2","cy2","ii"],"mappings":"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"}